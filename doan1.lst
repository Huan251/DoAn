CCS PCM C Compiler, Version 5.109, 43599               25-Dec-25 15:43

               Filename:   C:\Users\Huan\DoAn\doan1.lst

               ROM used:   5511 words (67%)
                           Largest free fragment is 2048
               RAM used:   78 (21%) at main() level
                           217 (59%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16F887.h>
.................... //////////// Standard Header file for the PIC16F887 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F887
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  37
0009:  RETLW  38
000A:  RETLW  39
000B:  RETLW  2F
000C:  RETLW  34
000D:  RETLW  35
000E:  RETLW  36
000F:  RETLW  2A
0010:  RETLW  31
0011:  RETLW  32
0012:  RETLW  33
0013:  RETLW  2D
0014:  RETLW  53
0015:  RETLW  30
0016:  RETLW  3D
0017:  RETLW  2B
0018:  BCF    0A.0
0019:  BCF    0A.1
001A:  BCF    0A.2
001B:  ADDWF  02,F
001C:  RETLW  43
001D:  RETLW  41
001E:  RETLW  49
001F:  RETLW  4A
0020:  RETLW  21
0021:  RETLW  5E
0022:  RETLW  44
0023:  RETLW  7C
0024:  RETLW  28
0025:  RETLW  29
0026:  RETLW  51
0027:  RETLW  58
0028:  RETLW  2E
0029:  RETLW  2E
002A:  RETLW  25
002B:  RETLW  56
*
0209:  BCF    0A.0
020A:  BSF    0A.1
020B:  BCF    0A.2
020C:  ADDWF  02,F
020D:  GOTO   199
020E:  GOTO   19E
020F:  GOTO   1A3
0210:  GOTO   1A8
0211:  BCF    0A.0
0212:  BSF    0A.1
0213:  BCF    0A.2
0214:  ADDWF  02,F
0215:  GOTO   1BD
0216:  GOTO   1C4
0217:  GOTO   1CB
0218:  GOTO   1D2
*
022D:  MOVF   32,W
022E:  MOVWF  04
022F:  BCF    03.7
0230:  BTFSC  33.0
0231:  BSF    03.7
0232:  MOVF   6F,W
0233:  MOVWF  00
0234:  INCF   04,F
0235:  CLRF   00
0236:  INCF   32,F
0237:  BTFSC  03.2
0238:  INCF   33,F
0239:  RETURN
023A:  CLRF   6E
023B:  MOVF   04,W
023C:  MOVWF  6D
023D:  BCF    6E.0
023E:  BTFSC  03.7
023F:  BSF    6E.0
0240:  BTFSS  67.7
0241:  GOTO   24A
0242:  BSF    6D.7
0243:  BTFSS  6D.4
0244:  INCF   6D,F
0245:  COMF   66,F
0246:  COMF   67,F
0247:  INCF   66,F
0248:  BTFSC  03.2
0249:  INCF   67,F
024A:  SWAPF  67,W
024B:  IORLW  F0
024C:  MOVWF  69
024D:  ADDWF  69,F
024E:  ADDLW  E2
024F:  MOVWF  6A
0250:  ADDLW  32
0251:  MOVWF  6C
0252:  MOVF   67,W
0253:  ANDLW  0F
0254:  ADDWF  6A,F
0255:  ADDWF  6A,F
0256:  ADDWF  6C,F
0257:  ADDLW  E9
0258:  MOVWF  6B
0259:  ADDWF  6B,F
025A:  ADDWF  6B,F
025B:  SWAPF  66,W
025C:  ANDLW  0F
025D:  ADDWF  6B,F
025E:  ADDWF  6C,F
025F:  RLF    6B,F
0260:  RLF    6C,F
0261:  COMF   6C,F
0262:  RLF    6C,F
0263:  MOVF   66,W
0264:  ANDLW  0F
0265:  ADDWF  6C,F
0266:  RLF    69,F
0267:  MOVLW  07
0268:  MOVWF  68
0269:  MOVLW  0A
026A:  ADDWF  6C,F
026B:  DECF   6B,F
026C:  BTFSS  03.0
026D:  GOTO   26A
026E:  ADDWF  6B,F
026F:  DECF   6A,F
0270:  BTFSS  03.0
0271:  GOTO   26E
0272:  ADDWF  6A,F
0273:  DECF   69,F
0274:  BTFSS  03.0
0275:  GOTO   272
0276:  ADDWF  69,F
0277:  DECF   68,F
0278:  BTFSS  03.0
0279:  GOTO   276
027A:  MOVLW  68
027B:  MOVWF  04
027C:  BCF    03.7
027D:  MOVLW  07
027E:  ANDWF  6D,W
027F:  BCF    6D.6
0280:  DECF   04,F
0281:  ANDWF  6D,W
0282:  BTFSS  03.2
0283:  GOTO   28B
0284:  BTFSC  6D.4
0285:  INCF   04,F
0286:  BTFSC  6D.4
0287:  GOTO   28B
0288:  MOVLW  20
0289:  MOVWF  77
028A:  GOTO   2A8
028B:  ADDWF  04,F
028C:  MOVLW  6C
028D:  SUBWF  04,W
028E:  BTFSC  03.2
028F:  BSF    6D.6
0290:  MOVF   00,W
0291:  MOVWF  77
0292:  BTFSS  03.2
0293:  GOTO   29C
0294:  BTFSC  6D.6
0295:  GOTO   29C
0296:  BTFSC  6D.4
0297:  GOTO   2B6
0298:  BTFSC  6D.3
0299:  GOTO   29C
029A:  MOVLW  20
029B:  GOTO   2A7
029C:  BTFSS  6D.7
029D:  GOTO   2A4
029E:  MOVLW  2D
029F:  MOVWF  77
02A0:  DECF   04,F
02A1:  BCF    6D.6
02A2:  BCF    6D.7
02A3:  GOTO   2A8
02A4:  BSF    6D.3
02A5:  BCF    6D.4
02A6:  MOVLW  30
02A7:  ADDWF  77,F
02A8:  CLRF   67
02A9:  MOVF   04,W
02AA:  MOVWF  66
02AB:  BCF    67.0
02AC:  BTFSC  03.7
02AD:  BSF    67.0
02AE:  MOVF   77,W
02AF:  MOVWF  6F
02B0:  CALL   22D
02B1:  MOVF   66,W
02B2:  MOVWF  04
02B3:  BCF    03.7
02B4:  BTFSC  67.0
02B5:  BSF    03.7
02B6:  INCF   04,F
02B7:  BTFSS  6D.6
02B8:  GOTO   28C
02B9:  RETURN
*
0310:  CLRF   78
0311:  CLRF   79
0312:  CLRF   77
0313:  CLRF   7A
0314:  BSF    03.6
0315:  MOVF   36,W
0316:  BTFSS  03.2
0317:  GOTO   31B
0318:  MOVF   35,W
0319:  BTFSC  03.2
031A:  GOTO   335
031B:  MOVLW  10
031C:  MOVWF  37
031D:  BCF    03.0
031E:  RLF    33,F
031F:  RLF    34,F
0320:  RLF    77,F
0321:  RLF    7A,F
0322:  MOVF   36,W
0323:  SUBWF  7A,W
0324:  BTFSS  03.2
0325:  GOTO   328
0326:  MOVF   35,W
0327:  SUBWF  77,W
0328:  BTFSS  03.0
0329:  GOTO   331
032A:  MOVF   35,W
032B:  SUBWF  77,F
032C:  BTFSS  03.0
032D:  DECF   7A,F
032E:  MOVF   36,W
032F:  SUBWF  7A,F
0330:  BSF    03.0
0331:  RLF    78,F
0332:  RLF    79,F
0333:  DECFSZ 37,F
0334:  GOTO   31D
0335:  BCF    03.6
0336:  RETURN
0337:  BSF    03.6
0338:  MOVF   34,W
0339:  XORWF  36,W
033A:  ANDLW  80
033B:  MOVWF  38
033C:  BTFSS  34.7
033D:  GOTO   343
033E:  COMF   33,F
033F:  COMF   34,F
0340:  INCF   33,F
0341:  BTFSC  03.2
0342:  INCF   34,F
0343:  BTFSS  36.7
0344:  GOTO   34A
0345:  COMF   35,F
0346:  COMF   36,F
0347:  INCF   35,F
0348:  BTFSC  03.2
0349:  INCF   36,F
034A:  MOVLW  10
034B:  MOVWF  37
034C:  CLRF   77
034D:  CLRF   7A
034E:  RRF    34,F
034F:  RRF    33,F
0350:  BTFSS  03.0
0351:  GOTO   358
0352:  MOVF   35,W
0353:  ADDWF  77,F
0354:  BTFSC  03.0
0355:  INCF   7A,F
0356:  MOVF   36,W
0357:  ADDWF  7A,F
0358:  RRF    7A,F
0359:  RRF    77,F
035A:  RRF    79,F
035B:  RRF    78,F
035C:  DECFSZ 37,F
035D:  GOTO   34E
035E:  BTFSS  38.7
035F:  GOTO   365
0360:  COMF   78,F
0361:  COMF   79,F
0362:  INCF   78,F
0363:  BTFSC  03.2
0364:  INCF   79,F
0365:  BCF    03.6
0366:  RETURN
*
03A4:  MOVLW  10
03A5:  MOVWF  2F
03A6:  CLRF   77
03A7:  CLRF   7A
03A8:  RRF    2C,F
03A9:  RRF    2B,F
03AA:  BTFSS  03.0
03AB:  GOTO   3B2
03AC:  MOVF   2D,W
03AD:  ADDWF  77,F
03AE:  BTFSC  03.0
03AF:  INCF   7A,F
03B0:  MOVF   2E,W
03B1:  ADDWF  7A,F
03B2:  RRF    7A,F
03B3:  RRF    77,F
03B4:  RRF    79,F
03B5:  RRF    78,F
03B6:  DECFSZ 2F,F
03B7:  GOTO   3A8
*
0518:  MOVF   6F,W
0519:  XORWF  71,W
051A:  ANDLW  80
051B:  MOVWF  73
051C:  BTFSS  6F.7
051D:  GOTO   523
051E:  COMF   6E,F
051F:  COMF   6F,F
0520:  INCF   6E,F
0521:  BTFSC  03.2
0522:  INCF   6F,F
0523:  BTFSS  71.7
0524:  GOTO   52A
0525:  COMF   70,F
0526:  COMF   71,F
0527:  INCF   70,F
0528:  BTFSC  03.2
0529:  INCF   71,F
052A:  CLRF   78
052B:  CLRF   79
052C:  CLRF   77
052D:  CLRF   7A
052E:  MOVF   71,W
052F:  BTFSS  03.2
0530:  GOTO   534
0531:  MOVF   70,W
0532:  BTFSC  03.2
0533:  GOTO   54E
0534:  MOVLW  10
0535:  MOVWF  72
0536:  BCF    03.0
0537:  RLF    6E,F
0538:  RLF    6F,F
0539:  RLF    77,F
053A:  RLF    7A,F
053B:  MOVF   71,W
053C:  SUBWF  7A,W
053D:  BTFSS  03.2
053E:  GOTO   541
053F:  MOVF   70,W
0540:  SUBWF  77,W
0541:  BTFSS  03.0
0542:  GOTO   54A
0543:  MOVF   70,W
0544:  SUBWF  77,F
0545:  BTFSS  03.0
0546:  DECF   7A,F
0547:  MOVF   71,W
0548:  SUBWF  7A,F
0549:  BSF    03.0
054A:  RLF    78,F
054B:  RLF    79,F
054C:  DECFSZ 72,F
054D:  GOTO   536
054E:  BTFSS  73.7
054F:  GOTO   555
0550:  COMF   78,F
0551:  COMF   79,F
0552:  INCF   78,F
0553:  BTFSC  03.2
0554:  INCF   79,F
0555:  RETURN
*
05F2:  CLRF   77
05F3:  CLRF   78
05F4:  MOVF   6A,W
05F5:  BCF    03.0
05F6:  BTFSC  6B.0
05F7:  ADDWF  77,F
05F8:  RRF    77,F
05F9:  RRF    78,F
05FA:  BTFSC  6B.1
05FB:  ADDWF  77,F
05FC:  RRF    77,F
05FD:  RRF    78,F
05FE:  BTFSC  6B.2
05FF:  ADDWF  77,F
0600:  RRF    77,F
0601:  RRF    78,F
0602:  BTFSC  6B.3
0603:  ADDWF  77,F
0604:  RRF    77,F
0605:  RRF    78,F
0606:  BTFSC  6B.4
0607:  ADDWF  77,F
0608:  RRF    77,F
0609:  RRF    78,F
060A:  BTFSC  6B.5
060B:  ADDWF  77,F
060C:  RRF    77,F
060D:  RRF    78,F
060E:  BTFSC  6B.6
060F:  ADDWF  77,F
0610:  RRF    77,F
0611:  RRF    78,F
0612:  BTFSC  6B.7
0613:  ADDWF  77,F
0614:  RRF    77,F
0615:  RRF    78,F
.................... 
.................... #list
.................... 
.................... #device *=16 adc=8
.................... #FUSES NOWDT, HS, NOPUT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT
.................... #use delay(clock = 20000000)
*
002C:  MOVLW  67
002D:  MOVWF  04
002E:  BCF    03.7
002F:  MOVF   00,W
0030:  BTFSC  03.2
0031:  GOTO   03F
0032:  MOVLW  06
0033:  MOVWF  78
0034:  CLRF   77
0035:  DECFSZ 77,F
0036:  GOTO   035
0037:  DECFSZ 78,F
0038:  GOTO   034
0039:  MOVLW  7B
003A:  MOVWF  77
003B:  DECFSZ 77,F
003C:  GOTO   03B
003D:  DECFSZ 00,F
003E:  GOTO   032
003F:  RETURN
.................... 
.................... // I2C master dùng cho LCD
.................... #use i2c(MASTER, SDA=PIN_C4, SCL=PIN_C3, FORCE_SW)
0040:  MOVLW  08
0041:  MOVWF  78
0042:  MOVLW  04
0043:  MOVWF  77
0044:  DECFSZ 77,F
0045:  GOTO   044
0046:  BCF    07.3
0047:  BCF    20.3
0048:  MOVF   20,W
0049:  BSF    03.5
004A:  MOVWF  07
004B:  MOVLW  03
004C:  MOVWF  77
004D:  DECFSZ 77,F
004E:  GOTO   04D
004F:  RLF    70,F
0050:  BCF    03.5
0051:  BCF    07.4
0052:  BTFSS  03.0
0053:  GOTO   05A
0054:  BSF    20.4
0055:  MOVF   20,W
0056:  BSF    03.5
0057:  MOVWF  07
0058:  GOTO   05E
0059:  BCF    03.5
005A:  BCF    20.4
005B:  MOVF   20,W
005C:  BSF    03.5
005D:  MOVWF  07
005E:  NOP
005F:  BCF    03.5
0060:  BSF    20.3
0061:  MOVF   20,W
0062:  BSF    03.5
0063:  MOVWF  07
0064:  BCF    03.5
0065:  BTFSS  07.3
0066:  GOTO   065
0067:  DECFSZ 78,F
0068:  GOTO   042
0069:  MOVLW  04
006A:  MOVWF  77
006B:  DECFSZ 77,F
006C:  GOTO   06B
006D:  BCF    07.3
006E:  BCF    20.3
006F:  MOVF   20,W
0070:  BSF    03.5
0071:  MOVWF  07
0072:  NOP
0073:  BCF    03.5
0074:  BSF    20.4
0075:  MOVF   20,W
0076:  BSF    03.5
0077:  MOVWF  07
0078:  MOVLW  03
0079:  MOVWF  77
007A:  DECFSZ 77,F
007B:  GOTO   07A
007C:  MOVLW  03
007D:  MOVWF  77
007E:  DECFSZ 77,F
007F:  GOTO   07E
0080:  BCF    03.5
0081:  BSF    20.3
0082:  MOVF   20,W
0083:  BSF    03.5
0084:  MOVWF  07
0085:  BCF    03.5
0086:  BTFSS  07.3
0087:  GOTO   086
0088:  CLRF   78
0089:  MOVLW  03
008A:  MOVWF  77
008B:  DECFSZ 77,F
008C:  GOTO   08B
008D:  BTFSC  07.4
008E:  BSF    78.0
008F:  BCF    07.3
0090:  BCF    20.3
0091:  MOVF   20,W
0092:  BSF    03.5
0093:  MOVWF  07
0094:  BCF    03.5
0095:  BCF    07.4
0096:  BCF    20.4
0097:  MOVF   20,W
0098:  BSF    03.5
0099:  MOVWF  07
009A:  BCF    03.5
009B:  RETURN
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
02BA:  BSF    03.6
02BB:  MOVF   26,W
02BC:  MOVWF  28
02BD:  MOVF   25,W
02BE:  MOVWF  27
02BF:  MOVF   28,W
02C0:  MOVWF  7A
02C1:  MOVF   27,W
02C2:  MOVWF  04
02C3:  BCF    03.7
02C4:  BTFSC  7A.0
02C5:  BSF    03.7
02C6:  MOVF   00,F
02C7:  BTFSC  03.2
02C8:  GOTO   2CD
02C9:  INCF   27,F
02CA:  BTFSC  03.2
02CB:  INCF   28,F
02CC:  GOTO   2BF
....................    return(sc - s);
02CD:  MOVF   25,W
02CE:  SUBWF  27,W
02CF:  MOVWF  77
02D0:  MOVF   28,W
02D1:  MOVWF  7A
02D2:  MOVF   26,W
02D3:  BTFSS  03.0
02D4:  INCFSZ 26,W
02D5:  SUBWF  7A,F
02D6:  MOVF   77,W
02D7:  MOVWF  78
02D8:  BCF    03.6
02D9:  RETURN
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
1022:  BCF    03.6
1023:  CLRF   21
1024:  CLRF   22
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... // LCD I2C
.................... #include "I2C_LCD.c"   // nhúng thý vi?n b?n ð? g?i
.................... // CCS C driver code for I2C LCDs (HD44780 compliant controllers)
.................... // https://simple-circuit.com/
.................... 
.................... 
.................... 
.................... #define LCD_BACKLIGHT          0x08
.................... #define LCD_NOBACKLIGHT        0x00
.................... #define LCD_FIRST_ROW          0x80
.................... #define LCD_SECOND_ROW         0xC0
.................... #define LCD_THIRD_ROW          0x94
.................... #define LCD_FOURTH_ROW         0xD4
.................... #define LCD_CLEAR              0x01
.................... #define LCD_RETURN_HOME        0x02
.................... #define LCD_ENTRY_MODE_SET     0x04
.................... #define LCD_CURSOR_OFF         0x0C
.................... #define LCD_UNDERLINE_ON       0x0E
.................... #define LCD_BLINK_CURSOR_ON    0x0F
.................... #define LCD_MOVE_CURSOR_LEFT   0x10
.................... #define LCD_MOVE_CURSOR_RIGHT  0x14
.................... #define LCD_TURN_ON            0x0C
.................... #define LCD_TURN_OFF           0x08
.................... #define LCD_SHIFT_LEFT         0x18
.................... #define LCD_SHIFT_RIGHT        0x1E
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... 
.................... int1 RS;
.................... unsigned int8 i2c_addr, backlight_val = LCD_BACKLIGHT;
.................... 
.................... void LCD_Write_Nibble(unsigned int8 n);
.................... void LCD_Cmd(unsigned int8 Command);
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row);
.................... void LCD_Out(unsigned int8 LCD_Char);
.................... void LCD_Begin(unsigned int8 _i2c_addr);
.................... void Backlight();
.................... void noBacklight();
.................... void Expander_Write(unsigned int8 value);
.................... 
.................... void LCD_Write_Nibble(unsigned int8 n) {
....................   n |= RS;
*
00E3:  MOVLW  00
00E4:  BTFSC  27.0
00E5:  MOVLW  01
00E6:  IORWF  6C,F
....................   Expander_Write(n);
00E7:  MOVF   6C,W
00E8:  MOVWF  6E
00E9:  CALL   09C
....................   Expander_Write(n | 0x04);
00EA:  MOVF   6C,W
00EB:  IORLW  04
00EC:  MOVWF  6D
00ED:  MOVWF  6E
00EE:  CALL   09C
....................   delay_us(1);
00EF:  GOTO   0F0
00F0:  GOTO   0F1
00F1:  NOP
....................   Expander_Write(n & 0xFB);
00F2:  MOVF   6C,W
00F3:  ANDLW  FB
00F4:  MOVWF  6D
00F5:  MOVWF  6E
00F6:  CALL   09C
....................   delay_us(50);
00F7:  MOVLW  53
00F8:  MOVWF  77
00F9:  DECFSZ 77,F
00FA:  GOTO   0F9
00FB:  RETURN
.................... }
.................... 
.................... void LCD_Cmd(unsigned int8 Command) {
....................   RS = 0;
00FC:  BCF    27.0
....................   LCD_Write_Nibble(Command & 0xF0);
00FD:  MOVF   6A,W
00FE:  ANDLW  F0
00FF:  MOVWF  6B
0100:  MOVWF  6C
0101:  CALL   0E3
....................   LCD_Write_Nibble((Command << 4) & 0xF0);
0102:  SWAPF  6A,W
0103:  MOVWF  77
0104:  MOVLW  F0
0105:  ANDWF  77,F
0106:  MOVF   77,W
0107:  ANDLW  F0
0108:  MOVWF  6B
0109:  MOVWF  6C
010A:  CALL   0E3
010B:  RETURN
.................... }
.................... 
.................... void LCD_Goto(unsigned int8 col, unsigned int8 row) {
....................   switch(row) {
*
0146:  MOVF   68,W
0147:  XORLW  02
0148:  BTFSC  03.2
0149:  GOTO   151
014A:  XORLW  01
014B:  BTFSC  03.2
014C:  GOTO   158
014D:  XORLW  07
014E:  BTFSC  03.2
014F:  GOTO   15F
0150:  GOTO   166
....................     case 2:
....................       LCD_Cmd(0xC0 + col-1);
0151:  MOVLW  C0
0152:  ADDWF  67,W
0153:  ADDLW  FF
0154:  MOVWF  69
0155:  MOVWF  6A
0156:  CALL   0FC
....................       break;
0157:  GOTO   16C
....................     case 3:
....................       LCD_Cmd(0x94 + col-1);
0158:  MOVLW  94
0159:  ADDWF  67,W
015A:  ADDLW  FF
015B:  MOVWF  69
015C:  MOVWF  6A
015D:  CALL   0FC
....................       break;
015E:  GOTO   16C
....................     case 4:
....................       LCD_Cmd(0xD4 + col-1);
015F:  MOVLW  D4
0160:  ADDWF  67,W
0161:  ADDLW  FF
0162:  MOVWF  69
0163:  MOVWF  6A
0164:  CALL   0FC
....................     break;
0165:  GOTO   16C
....................     default:      // case 1:
....................       LCD_Cmd(0x80 + col-1);
0166:  MOVLW  80
0167:  ADDWF  67,W
0168:  ADDLW  FF
0169:  MOVWF  69
016A:  MOVWF  6A
016B:  CALL   0FC
....................   }
016C:  RETURN
.................... }
.................... 
.................... void LCD_Out(unsigned int8 LCD_Char){
....................   RS = 1;
016D:  BSF    27.0
....................   LCD_Write_Nibble(LCD_Char & 0xF0);
016E:  MOVF   67,W
016F:  ANDLW  F0
0170:  MOVWF  68
0171:  MOVWF  6C
0172:  CALL   0E3
....................   LCD_Write_Nibble((LCD_Char << 4) & 0xF0);
0173:  SWAPF  67,W
0174:  MOVWF  77
0175:  MOVLW  F0
0176:  ANDWF  77,F
0177:  MOVF   77,W
0178:  ANDLW  F0
0179:  MOVWF  68
017A:  MOVWF  6C
017B:  CALL   0E3
017C:  RETURN
.................... }
.................... 
.................... void LCD_Begin(unsigned int8 _i2c_addr) {
....................   i2c_addr = _i2c_addr;
*
010C:  MOVF   66,W
010D:  MOVWF  28
....................   Expander_Write(0);
010E:  CLRF   6E
010F:  CALL   09C
....................   delay_ms(40);
0110:  MOVLW  28
0111:  MOVWF  67
0112:  CALL   02C
....................   LCD_Cmd(3);
0113:  MOVLW  03
0114:  MOVWF  6A
0115:  CALL   0FC
....................   delay_ms(5);
0116:  MOVLW  05
0117:  MOVWF  67
0118:  CALL   02C
....................   LCD_Cmd(3);
0119:  MOVLW  03
011A:  MOVWF  6A
011B:  CALL   0FC
....................   delay_ms(5);
011C:  MOVLW  05
011D:  MOVWF  67
011E:  CALL   02C
....................   LCD_Cmd(3);
011F:  MOVLW  03
0120:  MOVWF  6A
0121:  CALL   0FC
....................   delay_ms(5);
0122:  MOVLW  05
0123:  MOVWF  67
0124:  CALL   02C
....................   LCD_Cmd(LCD_RETURN_HOME);
0125:  MOVLW  02
0126:  MOVWF  6A
0127:  CALL   0FC
....................   delay_ms(5);
0128:  MOVLW  05
0129:  MOVWF  67
012A:  CALL   02C
....................   LCD_Cmd(0x20 | (LCD_TYPE << 2));
012B:  MOVLW  28
012C:  MOVWF  6A
012D:  CALL   0FC
....................   delay_ms(50);
012E:  MOVLW  32
012F:  MOVWF  67
0130:  CALL   02C
....................   LCD_Cmd(LCD_TURN_ON);
0131:  MOVLW  0C
0132:  MOVWF  6A
0133:  CALL   0FC
....................   delay_ms(50);
0134:  MOVLW  32
0135:  MOVWF  67
0136:  CALL   02C
....................   LCD_Cmd(LCD_CLEAR);
0137:  MOVLW  01
0138:  MOVWF  6A
0139:  CALL   0FC
....................   delay_ms(50);
013A:  MOVLW  32
013B:  MOVWF  67
013C:  CALL   02C
....................   LCD_Cmd(LCD_ENTRY_MODE_SET | LCD_RETURN_HOME);
013D:  MOVLW  06
013E:  MOVWF  6A
013F:  CALL   0FC
....................   delay_ms(50);
0140:  MOVLW  32
0141:  MOVWF  67
0142:  CALL   02C
0143:  BCF    0A.3
0144:  BSF    0A.4
0145:  GOTO   055 (RETURN)
.................... }
.................... 
.................... void Backlight() {
....................   backlight_val = LCD_BACKLIGHT;
....................   Expander_Write(0);
.................... }
.................... 
.................... void noBacklight() {
....................   backlight_val = LCD_NOBACKLIGHT;
....................   Expander_Write(0);
.................... }
.................... 
.................... void Expander_Write(unsigned int8 value) {
....................   i2c_start();
*
009C:  BSF    20.4
009D:  MOVF   20,W
009E:  BSF    03.5
009F:  MOVWF  07
00A0:  MOVLW  04
00A1:  MOVWF  77
00A2:  DECFSZ 77,F
00A3:  GOTO   0A2
00A4:  BCF    03.5
00A5:  BSF    20.3
00A6:  MOVF   20,W
00A7:  BSF    03.5
00A8:  MOVWF  07
00A9:  MOVLW  03
00AA:  MOVWF  77
00AB:  DECFSZ 77,F
00AC:  GOTO   0AB
00AD:  BCF    03.5
00AE:  BCF    07.4
00AF:  BCF    20.4
00B0:  MOVF   20,W
00B1:  BSF    03.5
00B2:  MOVWF  07
00B3:  MOVLW  04
00B4:  MOVWF  77
00B5:  DECFSZ 77,F
00B6:  GOTO   0B5
00B7:  BCF    03.5
00B8:  BCF    07.3
00B9:  BCF    20.3
00BA:  MOVF   20,W
00BB:  BSF    03.5
00BC:  MOVWF  07
....................   i2c_write(i2c_addr);              // ghi ð?a ch? I2C LCD
00BD:  BCF    03.5
00BE:  MOVF   28,W
00BF:  MOVWF  70
00C0:  CALL   040
....................   i2c_write(value | backlight_val); // g?i d? li?u kèm backlight
00C1:  MOVF   6E,W
00C2:  IORWF  29,W
00C3:  MOVWF  6F
00C4:  MOVWF  70
00C5:  CALL   040
....................   i2c_stop();
00C6:  BCF    20.4
00C7:  MOVF   20,W
00C8:  BSF    03.5
00C9:  MOVWF  07
00CA:  NOP
00CB:  BCF    03.5
00CC:  BSF    20.3
00CD:  MOVF   20,W
00CE:  BSF    03.5
00CF:  MOVWF  07
00D0:  BCF    03.5
00D1:  BTFSS  07.3
00D2:  GOTO   0D1
00D3:  MOVLW  04
00D4:  MOVWF  77
00D5:  DECFSZ 77,F
00D6:  GOTO   0D5
00D7:  GOTO   0D8
00D8:  NOP
00D9:  BSF    20.4
00DA:  MOVF   20,W
00DB:  BSF    03.5
00DC:  MOVWF  07
00DD:  MOVLW  04
00DE:  MOVWF  77
00DF:  DECFSZ 77,F
00E0:  GOTO   0DF
00E1:  BCF    03.5
00E2:  RETURN
.................... }
.................... 
.................... void lcd_print_string(char *s) {
....................     while(*s) LCD_Out(*s++);
.................... }
.................... 
.................... 
.................... #define LCD_ADDR 0x4E
.................... // ================== MA TR?N 4x4 ==================
.................... #define HANG_1 PIN_B0
.................... #define HANG_2 PIN_B1
.................... #define HANG_3 PIN_B2
.................... #define HANG_4 PIN_B3
.................... 
.................... #define COT_1 PIN_B4
.................... #define COT_2 PIN_B5
.................... #define COT_3 PIN_B6
.................... #define COT_4 PIN_B7
.................... 
.................... 
.................... // LAYOUT PHÍM
.................... const char PHIM_THUONG[4][4] = {
....................     {'7','8','9','/'}, 
....................     {'4','5','6','*'}, 
....................     {'1','2','3','-'}, 
....................     {'S','0','=','+'}
.................... };
.................... 
.................... const char PHIM_SHIFT[4][4] = {
....................     {'C','A','I','J'},
....................     {'!','^','D','|'},
....................     {'(',')','Q','X'},
....................     {'.','.','%','V'}
.................... };
.................... 
.................... // ================== BI?N TOÁN TÍNH ==================
.................... 
.................... signed long int ANS = 0;
.................... signed long int luu_gia_tri_I = 0;
.................... signed long int luu_gia_tri_J = 0;
.................... long int loi = 0;
.................... int1 shift_mode = 0;
.................... 
.................... void cap_nhat_shift_lcd() {
....................     if(shift_mode) {
*
0219:  BTFSS  27.1
021A:  GOTO   224
....................         LCD_Goto(16,1);
021B:  MOVLW  10
021C:  MOVWF  67
021D:  MOVLW  01
021E:  MOVWF  68
021F:  CALL   146
....................         LCD_Out('S');
0220:  MOVLW  53
0221:  MOVWF  67
0222:  CALL   16D
....................     } else {
0223:  GOTO   22C
....................         LCD_Goto(16,1);
0224:  MOVLW  10
0225:  MOVWF  67
0226:  MOVLW  01
0227:  MOVWF  68
0228:  CALL   146
....................         LCD_Out(' ');
0229:  MOVLW  20
022A:  MOVWF  67
022B:  CALL   16D
....................     }
022C:  RETURN
.................... }
.................... // ================== KHAI BÁO HÀM ==================
.................... char doc_phim() {
*
017D:  CLRF   68
....................     int8 hang, cot;
....................     char phim = 0;
.................... 
....................     for(hang = 0; hang < 4; hang++) {
017E:  CLRF   66
017F:  MOVF   66,W
0180:  SUBLW  03
0181:  BTFSS  03.0
0182:  GOTO   206
.................... 
....................         output_high(HANG_1);
0183:  BSF    03.5
0184:  BCF    06.0
0185:  BCF    03.5
0186:  BSF    06.0
....................         output_high(HANG_2);
0187:  BSF    03.5
0188:  BCF    06.1
0189:  BCF    03.5
018A:  BSF    06.1
....................         output_high(HANG_3);
018B:  BSF    03.5
018C:  BCF    06.2
018D:  BCF    03.5
018E:  BSF    06.2
....................         output_high(HANG_4);
018F:  BSF    03.5
0190:  BCF    06.3
0191:  BCF    03.5
0192:  BSF    06.3
.................... 
....................         switch(hang) {
0193:  MOVF   66,W
0194:  ADDLW  FC
0195:  BTFSC  03.0
0196:  GOTO   1AC
0197:  ADDLW  04
0198:  GOTO   209
....................             case 0: output_low(HANG_1); break;
0199:  BSF    03.5
019A:  BCF    06.0
019B:  BCF    03.5
019C:  BCF    06.0
019D:  GOTO   1AC
....................             case 1: output_low(HANG_2); break;
019E:  BSF    03.5
019F:  BCF    06.1
01A0:  BCF    03.5
01A1:  BCF    06.1
01A2:  GOTO   1AC
....................             case 2: output_low(HANG_3); break;
01A3:  BSF    03.5
01A4:  BCF    06.2
01A5:  BCF    03.5
01A6:  BCF    06.2
01A7:  GOTO   1AC
....................             case 3: output_low(HANG_4); break;
01A8:  BSF    03.5
01A9:  BCF    06.3
01AA:  BCF    03.5
01AB:  BCF    06.3
....................         }
.................... 
....................         delay_us(10);
01AC:  MOVLW  10
01AD:  MOVWF  77
01AE:  DECFSZ 77,F
01AF:  GOTO   1AE
01B0:  NOP
.................... 
....................         for(cot = 0; cot < 4; cot++) {
01B1:  CLRF   67
01B2:  MOVF   67,W
01B3:  SUBLW  03
01B4:  BTFSS  03.0
01B5:  GOTO   204
....................             int1 nhan = 0;
01B6:  BCF    69.0
.................... 
....................             switch(cot) {
01B7:  MOVF   67,W
01B8:  ADDLW  FC
01B9:  BTFSC  03.0
01BA:  GOTO   1D8
01BB:  ADDLW  04
01BC:  GOTO   211
....................                 case 0: nhan = !input(COT_1); break;
01BD:  BSF    03.5
01BE:  BSF    06.4
01BF:  BCF    03.5
01C0:  BCF    69.0
01C1:  BTFSS  06.4
01C2:  BSF    69.0
01C3:  GOTO   1D8
....................                 case 1: nhan = !input(COT_2); break;
01C4:  BSF    03.5
01C5:  BSF    06.5
01C6:  BCF    03.5
01C7:  BCF    69.0
01C8:  BTFSS  06.5
01C9:  BSF    69.0
01CA:  GOTO   1D8
....................                 case 2: nhan = !input(COT_3); break;
01CB:  BSF    03.5
01CC:  BSF    06.6
01CD:  BCF    03.5
01CE:  BCF    69.0
01CF:  BTFSS  06.6
01D0:  BSF    69.0
01D1:  GOTO   1D8
....................                 case 3: nhan = !input(COT_4); break;
01D2:  BSF    03.5
01D3:  BSF    06.7
01D4:  BCF    03.5
01D5:  BCF    69.0
01D6:  BTFSS  06.7
01D7:  BSF    69.0
....................             }
.................... 
....................             if(nhan) {
01D8:  BTFSS  69.0
01D9:  GOTO   202
.................... 
....................     // ===== PHÍM SHIFT (V? TRÍ C? Ð?NH) =====
....................     if(PHIM_THUONG[hang][cot] == 'S') {
01DA:  RLF    66,W
01DB:  MOVWF  77
01DC:  RLF    77,F
01DD:  MOVLW  FC
01DE:  ANDWF  77,F
01DF:  MOVF   77,W
01E0:  ADDWF  67,W
01E1:  CALL   004
01E2:  SUBLW  53
01E3:  BTFSS  03.2
01E4:  GOTO   1E8
....................         return 'S';
01E5:  MOVLW  53
01E6:  MOVWF  78
01E7:  GOTO   208
....................     }
.................... 
....................     // ===== PHÍM KHÁC =====
....................     if(shift_mode)
01E8:  BTFSS  27.1
01E9:  GOTO   1F5
....................         phim = PHIM_SHIFT[hang][cot];
01EA:  RLF    66,W
01EB:  MOVWF  77
01EC:  RLF    77,F
01ED:  MOVLW  FC
01EE:  ANDWF  77,F
01EF:  MOVF   77,W
01F0:  ADDWF  67,W
01F1:  CALL   018
01F2:  MOVWF  78
01F3:  MOVWF  68
01F4:  GOTO   1FF
....................     else
....................         phim = PHIM_THUONG[hang][cot];
01F5:  RLF    66,W
01F6:  MOVWF  77
01F7:  RLF    77,F
01F8:  MOVLW  FC
01F9:  ANDWF  77,F
01FA:  MOVF   77,W
01FB:  ADDWF  67,W
01FC:  CALL   004
01FD:  MOVWF  78
01FE:  MOVWF  68
.................... 
....................     return phim;
01FF:  MOVF   68,W
0200:  MOVWF  78
0201:  GOTO   208
.................... }
0202:  INCF   67,F
0203:  GOTO   1B2
.................... 
....................         }
0204:  INCF   66,F
0205:  GOTO   17F
....................     }
....................     return 0;
0206:  MOVLW  00
0207:  MOVWF  78
0208:  RETURN
.................... }
.................... 
.................... 
.................... // ============= CÁC HÀM TÍNH TOÁN (GI? NGUYÊN 100%) =============
.................... 
.................... signed long uu_tien_toan_tu(char toan_tu) {
....................     if (toan_tu == '+' || toan_tu == '-') return 1;
*
02DA:  BSF    03.6
02DB:  MOVF   25,W
02DC:  SUBLW  2B
02DD:  BTFSC  03.2
02DE:  GOTO   2E3
02DF:  MOVF   25,W
02E0:  SUBLW  2D
02E1:  BTFSS  03.2
02E2:  GOTO   2E8
02E3:  MOVLW  01
02E4:  MOVWF  78
02E5:  MOVLW  00
02E6:  MOVWF  79
02E7:  GOTO   30E
....................     if (toan_tu == '*' || toan_tu == '/' || toan_tu == '%') return 2;
02E8:  MOVF   25,W
02E9:  SUBLW  2A
02EA:  BTFSC  03.2
02EB:  GOTO   2F4
02EC:  MOVF   25,W
02ED:  SUBLW  2F
02EE:  BTFSC  03.2
02EF:  GOTO   2F4
02F0:  MOVF   25,W
02F1:  SUBLW  25
02F2:  BTFSS  03.2
02F3:  GOTO   2F9
02F4:  MOVLW  02
02F5:  MOVWF  78
02F6:  MOVLW  00
02F7:  MOVWF  79
02F8:  GOTO   30E
....................     if (toan_tu == '^') return 3;
02F9:  MOVF   25,W
02FA:  SUBLW  5E
02FB:  BTFSS  03.2
02FC:  GOTO   302
02FD:  MOVLW  03
02FE:  MOVWF  78
02FF:  MOVLW  00
0300:  MOVWF  79
0301:  GOTO   30E
....................     if (toan_tu == '!') return 4;
0302:  MOVF   25,W
0303:  SUBLW  21
0304:  BTFSS  03.2
0305:  GOTO   30B
0306:  MOVLW  04
0307:  MOVWF  78
0308:  MOVLW  00
0309:  MOVWF  79
030A:  GOTO   30E
....................     return 0;
030B:  MOVLW  00
030C:  MOVWF  78
030D:  MOVWF  79
030E:  BCF    03.6
030F:  RETURN
.................... }
.................... 
.................... signed long phep_toan(char c) {
....................     return (c == '+' || c == '-' || c == '*' || 
....................             c == '/' || c == '^' || c == '%');
*
04F6:  BSF    03.6
04F7:  MOVF   28,W
04F8:  SUBLW  2B
04F9:  BTFSC  03.2
04FA:  GOTO   511
04FB:  MOVF   28,W
04FC:  SUBLW  2D
04FD:  BTFSC  03.2
04FE:  GOTO   511
04FF:  MOVF   28,W
0500:  SUBLW  2A
0501:  BTFSC  03.2
0502:  GOTO   511
0503:  MOVF   28,W
0504:  SUBLW  2F
0505:  BTFSC  03.2
0506:  GOTO   511
0507:  MOVF   28,W
0508:  SUBLW  5E
0509:  BTFSC  03.2
050A:  GOTO   511
050B:  MOVF   28,W
050C:  SUBLW  25
050D:  BTFSC  03.2
050E:  GOTO   511
050F:  MOVLW  00
0510:  GOTO   512
0511:  MOVLW  01
0512:  CLRF   7A
0513:  MOVWF  78
0514:  MOVF   7A,W
0515:  MOVWF  79
0516:  BCF    03.6
0517:  RETURN
.................... }
.................... 
.................... signed long  tinh_luy_thua(long int co_so, long int so_mu) {
....................     if (co_so == 0){
*
0409:  MOVF   2B,F
040A:  BTFSS  03.2
040B:  GOTO   430
040C:  MOVF   2C,F
040D:  BTFSS  03.2
040E:  GOTO   430
....................       if (so_mu > 0) return 0;
040F:  MOVF   2D,F
0410:  BTFSS  03.2
0411:  GOTO   415
0412:  MOVF   2E,F
0413:  BTFSC  03.2
0414:  GOTO   41A
0415:  MOVLW  00
0416:  MOVWF  78
0417:  MOVWF  79
0418:  GOTO   4ED
0419:  GOTO   42F
....................       else if (so_mu == 0) return 1;
041A:  MOVF   2D,F
041B:  BTFSS  03.2
041C:  GOTO   426
041D:  MOVF   2E,F
041E:  BTFSS  03.2
041F:  GOTO   426
0420:  MOVLW  01
0421:  MOVWF  78
0422:  MOVLW  00
0423:  MOVWF  79
0424:  GOTO   4ED
0425:  GOTO   42F
....................       else {
....................          loi = 1;
0426:  BCF    03.6
0427:  CLRF   31
0428:  MOVLW  01
0429:  MOVWF  30
....................          return 0;
042A:  MOVLW  00
042B:  MOVWF  78
042C:  MOVWF  79
042D:  BSF    03.6
042E:  GOTO   4ED
....................       }
....................     }
042F:  GOTO   453
....................     else if (co_so == 1) return 1;
0430:  DECFSZ 2B,W
0431:  GOTO   43B
0432:  MOVF   2C,F
0433:  BTFSS  03.2
0434:  GOTO   43B
0435:  MOVLW  01
0436:  MOVWF  78
0437:  MOVLW  00
0438:  MOVWF  79
0439:  GOTO   4ED
043A:  GOTO   453
....................     else if (co_so == -1) {
043B:  INCFSZ 2B,W
043C:  GOTO   453
043D:  INCFSZ 2C,W
043E:  GOTO   453
....................         if (so_mu % 2 == 0) return 1;
043F:  MOVF   2D,W
0440:  ANDLW  01
0441:  MOVWF  33
0442:  CLRF   34
0443:  MOVF   33,F
0444:  BTFSS  03.2
0445:  GOTO   44F
0446:  MOVF   34,F
0447:  BTFSS  03.2
0448:  GOTO   44F
0449:  MOVLW  01
044A:  MOVWF  78
044B:  MOVLW  00
044C:  MOVWF  79
044D:  GOTO   4ED
044E:  GOTO   453
....................         else return -1;
044F:  MOVLW  FF
0450:  MOVWF  78
0451:  MOVWF  79
0452:  GOTO   4ED
....................     }
....................     if(so_mu < 0) return 0;
....................     signed long  ket_qua = 1;
0453:  CLRF   30
0454:  MOVLW  01
0455:  MOVWF  2F
....................     if (co_so != 0 && so_mu > 0) {
0456:  MOVF   2B,F
0457:  BTFSS  03.2
0458:  GOTO   45C
0459:  MOVF   2C,F
045A:  BTFSC  03.2
045B:  GOTO   490
045C:  MOVF   2D,F
045D:  BTFSS  03.2
045E:  GOTO   462
045F:  MOVF   2E,F
0460:  BTFSC  03.2
0461:  GOTO   490
....................         if (so_mu >= 15 && co_so >= 2) {
0462:  MOVF   2E,F
0463:  BTFSS  03.2
0464:  GOTO   469
0465:  MOVF   2D,W
0466:  SUBLW  0E
0467:  BTFSC  03.0
0468:  GOTO   479
0469:  MOVF   2C,F
046A:  BTFSS  03.2
046B:  GOTO   470
046C:  MOVF   2B,W
046D:  SUBLW  01
046E:  BTFSC  03.0
046F:  GOTO   479
....................             loi = 2;
0470:  BCF    03.6
0471:  CLRF   31
0472:  MOVLW  02
0473:  MOVWF  30
....................             return 0;
0474:  MOVLW  00
0475:  MOVWF  78
0476:  MOVWF  79
0477:  BSF    03.6
0478:  GOTO   4ED
....................         }
....................         if (so_mu >= 1 && co_so > 181) {
0479:  MOVF   2E,F
047A:  BTFSS  03.2
047B:  GOTO   480
047C:  MOVF   2D,W
047D:  SUBLW  00
047E:  BTFSC  03.0
047F:  GOTO   490
0480:  MOVF   2C,F
0481:  BTFSS  03.2
0482:  GOTO   487
0483:  MOVF   2B,W
0484:  SUBLW  B5
0485:  BTFSC  03.0
0486:  GOTO   490
....................             loi = 2;
0487:  BCF    03.6
0488:  CLRF   31
0489:  MOVLW  02
048A:  MOVWF  30
....................             return 0;
048B:  MOVLW  00
048C:  MOVWF  78
048D:  MOVWF  79
048E:  BSF    03.6
048F:  GOTO   4ED
....................         }
....................     }
....................     for (long int i = 0; i < so_mu; i++) {
0490:  CLRF   32
0491:  CLRF   31
0492:  MOVF   32,W
0493:  SUBWF  2E,W
0494:  BTFSS  03.0
0495:  GOTO   4E9
0496:  BTFSS  03.2
0497:  GOTO   49C
0498:  MOVF   2D,W
0499:  SUBWF  31,W
049A:  BTFSC  03.0
049B:  GOTO   4E9
....................         if (co_so != 0 && (long int)
....................         
....................         767 / ABS(co_so) < ABS(ket_qua)) {
049C:  MOVF   2B,F
049D:  BTFSS  03.2
049E:  GOTO   4A2
049F:  MOVF   2C,F
04A0:  BTFSC  03.2
04A1:  GOTO   4D6
04A2:  MOVF   2C,W
04A3:  MOVWF  7A
04A4:  MOVF   2B,W
04A5:  MOVLW  02
04A6:  MOVWF  34
04A7:  MOVLW  FF
04A8:  MOVWF  33
04A9:  MOVF   2C,W
04AA:  MOVWF  36
04AB:  MOVF   2B,W
04AC:  MOVWF  35
04AD:  BCF    03.6
04AE:  CALL   310
04AF:  MOVF   79,W
04B0:  BSF    03.6
04B1:  MOVWF  34
04B2:  MOVF   78,W
04B3:  MOVWF  33
04B4:  MOVF   30,W
04B5:  MOVWF  7A
04B6:  MOVF   2F,W
04B7:  BTFSS  30.7
04B8:  GOTO   4C2
04B9:  MOVF   2F,W
04BA:  SUBLW  00
04BB:  MOVWF  77
04BC:  CLRF   7A
04BD:  MOVF   30,W
04BE:  BTFSS  03.0
04BF:  INCFSZ 30,W
04C0:  SUBWF  7A,F
04C1:  MOVF   77,W
04C2:  MOVWF  78
04C3:  MOVF   34,W
04C4:  SUBWF  7A,W
04C5:  BTFSS  03.0
04C6:  GOTO   4D6
04C7:  BTFSS  03.2
04C8:  GOTO   4CD
04C9:  MOVF   78,W
04CA:  SUBWF  33,W
04CB:  BTFSC  03.0
04CC:  GOTO   4D6
....................             loi = 2;
04CD:  BCF    03.6
04CE:  CLRF   31
04CF:  MOVLW  02
04D0:  MOVWF  30
....................             return 0;
04D1:  MOVLW  00
04D2:  MOVWF  78
04D3:  MOVWF  79
04D4:  BSF    03.6
04D5:  GOTO   4ED
....................         }
....................         ket_qua *= co_so;
04D6:  MOVF   30,W
04D7:  MOVWF  34
04D8:  MOVF   2F,W
04D9:  MOVWF  33
04DA:  MOVF   2C,W
04DB:  MOVWF  36
04DC:  MOVF   2B,W
04DD:  MOVWF  35
04DE:  BCF    03.6
04DF:  CALL   337
04E0:  MOVF   79,W
04E1:  BSF    03.6
04E2:  MOVWF  30
04E3:  MOVF   78,W
04E4:  MOVWF  2F
04E5:  INCF   31,F
04E6:  BTFSC  03.2
04E7:  INCF   32,F
04E8:  GOTO   492
....................     }
....................     return ket_qua;
04E9:  MOVF   2F,W
04EA:  MOVWF  78
04EB:  MOVF   30,W
04EC:  MOVWF  79
.................... }
.................... 
.................... signed long tinh_toan(long int so_a, long int so_b, char toan_tu) {
....................     switch (toan_tu) {
*
0367:  BSF    03.6
0368:  MOVF   2A,W
0369:  XORLW  2B
036A:  BCF    03.6
036B:  BTFSC  03.2
036C:  GOTO   37D
036D:  XORLW  06
036E:  BTFSC  03.2
036F:  GOTO   38B
0370:  XORLW  07
0371:  BTFSC  03.2
0372:  GOTO   39B
0373:  XORLW  05
0374:  BTFSC  03.2
0375:  GOTO   3BE
0376:  XORLW  0A
0377:  BTFSC  03.2
0378:  GOTO   3DF
0379:  XORLW  7B
037A:  BTFSC  03.2
037B:  GOTO   400
037C:  GOTO   4F0
....................         case '+': return so_a + so_b;
037D:  BSF    03.6
037E:  MOVF   28,W
037F:  ADDWF  26,W
0380:  MOVWF  78
0381:  MOVF   27,W
0382:  MOVWF  7A
0383:  MOVF   29,W
0384:  BTFSC  03.0
0385:  INCFSZ 29,W
0386:  ADDWF  7A,F
0387:  MOVF   7A,W
0388:  MOVWF  79
0389:  GOTO   4F4
038A:  BCF    03.6
....................         case '-': return so_a - so_b;
038B:  BSF    03.6
038C:  MOVF   28,W
038D:  SUBWF  26,W
038E:  MOVWF  77
038F:  MOVF   27,W
0390:  MOVWF  7A
0391:  MOVF   29,W
0392:  BTFSS  03.0
0393:  INCFSZ 29,W
0394:  SUBWF  7A,F
0395:  MOVF   77,W
0396:  MOVWF  78
0397:  MOVF   7A,W
0398:  MOVWF  79
0399:  GOTO   4F4
039A:  BCF    03.6
....................         case '*': return so_a * so_b;
039B:  BSF    03.6
039C:  MOVF   27,W
039D:  MOVWF  2C
039E:  MOVF   26,W
039F:  MOVWF  2B
03A0:  MOVF   29,W
03A1:  MOVWF  2E
03A2:  MOVF   28,W
03A3:  MOVWF  2D
*
03B8:  MOVF   79,W
03B9:  MOVWF  7A
03BA:  MOVF   7A,W
03BB:  MOVWF  79
03BC:  GOTO   4F4
03BD:  BCF    03.6
....................         case '/':
....................             if (so_b == 0) {
03BE:  BSF    03.6
03BF:  MOVF   28,F
03C0:  BTFSS  03.2
03C1:  GOTO   3CE
03C2:  MOVF   29,F
03C3:  BTFSS  03.2
03C4:  GOTO   3CE
....................                 loi = 1;
03C5:  BCF    03.6
03C6:  CLRF   31
03C7:  MOVLW  01
03C8:  MOVWF  30
....................                 return 0;
03C9:  MOVLW  00
03CA:  MOVWF  78
03CB:  MOVWF  79
03CC:  BSF    03.6
03CD:  GOTO   4F4
....................             }
....................             return so_a / so_b;
03CE:  MOVF   27,W
03CF:  MOVWF  34
03D0:  MOVF   26,W
03D1:  MOVWF  33
03D2:  MOVF   29,W
03D3:  MOVWF  36
03D4:  MOVF   28,W
03D5:  MOVWF  35
03D6:  BCF    03.6
03D7:  CALL   310
03D8:  MOVF   79,W
03D9:  MOVWF  7A
03DA:  MOVF   7A,W
03DB:  MOVWF  79
03DC:  BSF    03.6
03DD:  GOTO   4F4
03DE:  BCF    03.6
.................... 
....................         case '%':
....................             if (so_b == 0) {
03DF:  BSF    03.6
03E0:  MOVF   28,F
03E1:  BTFSS  03.2
03E2:  GOTO   3EF
03E3:  MOVF   29,F
03E4:  BTFSS  03.2
03E5:  GOTO   3EF
....................                 loi = 1;   
03E6:  BCF    03.6
03E7:  CLRF   31
03E8:  MOVLW  01
03E9:  MOVWF  30
....................                 return 0;
03EA:  MOVLW  00
03EB:  MOVWF  78
03EC:  MOVWF  79
03ED:  BSF    03.6
03EE:  GOTO   4F4
....................             }
....................             return so_a % so_b;
03EF:  MOVF   27,W
03F0:  MOVWF  34
03F1:  MOVF   26,W
03F2:  MOVWF  33
03F3:  MOVF   29,W
03F4:  MOVWF  36
03F5:  MOVF   28,W
03F6:  MOVWF  35
03F7:  BCF    03.6
03F8:  CALL   310
03F9:  MOVF   77,W
03FA:  MOVWF  78
03FB:  MOVF   7A,W
03FC:  MOVWF  79
03FD:  BSF    03.6
03FE:  GOTO   4F4
03FF:  BCF    03.6
.................... 
....................         case '^': return tinh_luy_thua(so_a, so_b);
0400:  BSF    03.6
0401:  MOVF   27,W
0402:  MOVWF  2C
0403:  MOVF   26,W
0404:  MOVWF  2B
0405:  MOVF   29,W
0406:  MOVWF  2E
0407:  MOVF   28,W
0408:  MOVWF  2D
*
04ED:  MOVF   79,W
04EE:  GOTO   4F4
04EF:  BCF    03.6
....................     }
....................     return 0;
04F0:  MOVLW  00
04F1:  MOVWF  78
04F2:  MOVWF  79
04F3:  BSF    03.6
04F4:  BCF    03.6
04F5:  RETURN
.................... }
.................... 
.................... 
.................... signed long  tinh_giai_thua(long int so_n) {
....................     if (so_n < 0) {
....................         loi = 1;
....................         return 0;
....................     }
....................     if (so_n == 0 || so_n == 1) return 1;
*
0CEE:  MOVF   27,F
0CEF:  BTFSS  03.2
0CF0:  GOTO   4F4
0CF1:  MOVF   28,F
0CF2:  BTFSC  03.2
0CF3:  GOTO   4F9
0CF4:  DECFSZ 27,W
0CF5:  GOTO   4FE
0CF6:  MOVF   28,F
0CF7:  BTFSS  03.2
0CF8:  GOTO   4FE
0CF9:  MOVLW  01
0CFA:  MOVWF  78
0CFB:  MOVLW  00
0CFC:  MOVWF  79
0CFD:  GOTO   537
....................     if (so_n > 7) {
0CFE:  MOVF   28,F
0CFF:  BTFSS  03.2
0D00:  GOTO   505
0D01:  MOVF   27,W
0D02:  SUBLW  07
0D03:  BTFSC  03.0
0D04:  GOTO   50E
....................         loi = 2;
0D05:  BCF    03.6
0D06:  CLRF   31
0D07:  MOVLW  02
0D08:  MOVWF  30
....................         return 0;
0D09:  MOVLW  00
0D0A:  MOVWF  78
0D0B:  MOVWF  79
0D0C:  BSF    03.6
0D0D:  GOTO   537
....................     }
....................     signed long  ket_qua = 1;
0D0E:  CLRF   2A
0D0F:  MOVLW  01
0D10:  MOVWF  29
....................     for (long int i = 2; i <= so_n; i++) {
0D11:  CLRF   2C
0D12:  MOVLW  02
0D13:  MOVWF  2B
0D14:  MOVF   2C,W
0D15:  SUBWF  28,W
0D16:  BTFSS  03.0
0D17:  GOTO   533
0D18:  BTFSS  03.2
0D19:  GOTO   51E
0D1A:  MOVF   2B,W
0D1B:  SUBWF  27,W
0D1C:  BTFSS  03.0
0D1D:  GOTO   533
....................         ket_qua *= i;
0D1E:  MOVF   2A,W
0D1F:  MOVWF  34
0D20:  MOVF   29,W
0D21:  MOVWF  33
0D22:  MOVF   2C,W
0D23:  MOVWF  36
0D24:  MOVF   2B,W
0D25:  MOVWF  35
0D26:  BCF    0A.3
0D27:  BCF    03.6
0D28:  CALL   337
0D29:  BSF    0A.3
0D2A:  MOVF   79,W
0D2B:  BSF    03.6
0D2C:  MOVWF  2A
0D2D:  MOVF   78,W
0D2E:  MOVWF  29
0D2F:  INCF   2B,F
0D30:  BTFSC  03.2
0D31:  INCF   2C,F
0D32:  GOTO   514
....................     }
....................     return ket_qua;
0D33:  MOVF   29,W
0D34:  MOVWF  78
0D35:  MOVF   2A,W
0D36:  MOVWF  79
.................... }
.................... 
.................... signed long tinh_sqrt(signed long n) {
....................     if (n < 0) { loi = 1; return 0; }
*
0556:  BTFSS  67.7
0557:  GOTO   55F
0558:  CLRF   31
0559:  MOVLW  01
055A:  MOVWF  30
055B:  MOVLW  00
055C:  MOVWF  78
055D:  MOVWF  79
055E:  GOTO   5B2
....................     if (n <= 1) return n;
055F:  BTFSC  67.7
0560:  GOTO   568
0561:  MOVF   67,F
0562:  BTFSS  03.2
0563:  GOTO   56D
0564:  MOVF   66,W
0565:  SUBLW  01
0566:  BTFSS  03.0
0567:  GOTO   56D
0568:  MOVF   66,W
0569:  MOVWF  78
056A:  MOVF   67,W
056B:  MOVWF  79
056C:  GOTO   5B2
....................     
....................     signed long x = n / 2;
....................     signed long prev;
056D:  MOVF   67,W
056E:  MOVWF  6F
056F:  MOVF   66,W
0570:  MOVWF  6E
0571:  CLRF   71
0572:  MOVLW  02
0573:  MOVWF  70
0574:  CALL   518
0575:  MOVF   79,W
0576:  MOVWF  69
0577:  MOVF   78,W
0578:  MOVWF  68
....................     
....................     do {
....................         prev = x;
0579:  MOVF   69,W
057A:  MOVWF  6B
057B:  MOVF   68,W
057C:  MOVWF  6A
....................         x = (x + n / x) / 2;
057D:  MOVF   67,W
057E:  MOVWF  6F
057F:  MOVF   66,W
0580:  MOVWF  6E
0581:  MOVF   69,W
0582:  MOVWF  71
0583:  MOVF   68,W
0584:  MOVWF  70
0585:  CALL   518
0586:  MOVF   79,W
0587:  MOVWF  7A
0588:  MOVF   78,W
0589:  ADDWF  68,W
058A:  MOVWF  6C
058B:  MOVF   69,W
058C:  MOVWF  6D
058D:  MOVF   79,W
058E:  BTFSC  03.0
058F:  INCFSZ 79,W
0590:  ADDWF  6D,F
0591:  MOVF   6D,W
0592:  MOVWF  6F
0593:  MOVF   6C,W
0594:  MOVWF  6E
0595:  CLRF   71
0596:  MOVLW  02
0597:  MOVWF  70
0598:  CALL   518
0599:  MOVF   79,W
059A:  MOVWF  69
059B:  MOVF   78,W
059C:  MOVWF  68
....................     } while (x < prev);
059D:  BTFSS  69.7
059E:  GOTO   5A2
059F:  BTFSS  6B.7
05A0:  GOTO   579
05A1:  GOTO   5A4
05A2:  BTFSC  6B.7
05A3:  GOTO   5AE
05A4:  MOVF   69,W
05A5:  SUBWF  6B,W
05A6:  BTFSS  03.0
05A7:  GOTO   5AE
05A8:  BTFSS  03.2
05A9:  GOTO   579
05AA:  MOVF   6A,W
05AB:  SUBWF  68,W
05AC:  BTFSS  03.0
05AD:  GOTO   579
....................     
....................     return prev;
05AE:  MOVF   6A,W
05AF:  MOVWF  78
05B0:  MOVF   6B,W
05B1:  MOVWF  79
05B2:  BCF    0A.3
05B3:  BSF    0A.4
05B4:  GOTO   569 (RETURN)
.................... }
.................... 
.................... signed long tinh_bieu_thuc(char *bieu_thuc) {
*
0800:  MOVLW  FF
0801:  MOVWF  68
0802:  MOVWF  69
....................     signed long val[20];
....................     char op[20];
....................     int vtop = -1, otop = -1;
....................     signed long i;
.................... 
....................     loi = 0;
0803:  CLRF   31
0804:  CLRF   30
.................... 
....................     for (i = 0; i < strlen(bieu_thuc); i++) {
0805:  CLRF   6B
0806:  CLRF   6A
0807:  MOVF   67,W
0808:  BSF    03.6
0809:  MOVWF  26
080A:  BCF    03.6
080B:  MOVF   66,W
080C:  BSF    03.6
080D:  MOVWF  25
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   2BA
0811:  BSF    0A.3
0812:  BTFSC  6B.7
0813:  GOTO   01B
0814:  MOVF   6B,F
0815:  BTFSS  03.2
0816:  GOTO   6D9
0817:  MOVF   78,W
0818:  SUBWF  6A,W
0819:  BTFSC  03.0
081A:  GOTO   6D9
....................         char c = bieu_thuc[i];
081B:  MOVF   66,W
081C:  ADDWF  6A,W
081D:  MOVWF  04
081E:  BCF    03.7
081F:  BTFSC  67.0
0820:  BSF    03.7
0821:  MOVF   00,W
0822:  MOVWF  6C
....................         if (c == ' ') continue;
0823:  MOVF   6C,W
0824:  SUBLW  20
0825:  BTFSS  03.2
0826:  GOTO   028
0827:  GOTO   6D3
.................... 
....................         /* ===== X? L? 'A' (ANS) ===== */
....................        /* ===== X? L? 'A' (ANS) ===== */
.................... if (c == 'A') {
0828:  MOVF   6C,W
0829:  SUBLW  41
082A:  BTFSS  03.2
082B:  GOTO   11B
....................     // N?u trý?c A là s? ho?c ) ho?c A/I/J ? thêm phép nhân ng?m
....................     if (i > 0) {
082C:  BTFSC  6B.7
082D:  GOTO   10E
082E:  MOVF   6B,F
082F:  BTFSS  03.2
0830:  GOTO   035
0831:  MOVF   6A,W
0832:  SUBLW  00
0833:  BTFSC  03.0
0834:  GOTO   10E
....................         char prev = bieu_thuc[i-1];
0835:  MOVLW  01
0836:  SUBWF  6A,W
0837:  BSF    03.6
0838:  MOVWF  10
0839:  BCF    03.6
083A:  MOVF   6B,W
083B:  BSF    03.6
083C:  MOVWF  11
083D:  MOVLW  00
083E:  BTFSS  03.0
083F:  MOVLW  01
0840:  SUBWF  11,F
0841:  BCF    03.6
0842:  MOVF   66,W
0843:  BSF    03.6
0844:  ADDWF  10,W
0845:  MOVWF  04
0846:  BCF    03.7
0847:  BCF    03.6
0848:  BTFSC  67.0
0849:  BSF    03.7
084A:  MOVF   00,W
084B:  MOVWF  6D
....................         if ((prev >= '0' && prev <= '9') || prev == ')' || 
....................             prev == 'A' || prev == 'I' || prev == 'J') {
084C:  MOVF   6D,W
084D:  SUBLW  2F
084E:  BTFSC  03.0
084F:  GOTO   054
0850:  MOVF   6D,W
0851:  SUBLW  39
0852:  BTFSC  03.0
0853:  GOTO   064
0854:  MOVF   6D,W
0855:  SUBLW  29
0856:  BTFSC  03.2
0857:  GOTO   064
0858:  MOVF   6D,W
0859:  SUBLW  41
085A:  BTFSC  03.2
085B:  GOTO   064
085C:  MOVF   6D,W
085D:  SUBLW  49
085E:  BTFSC  03.2
085F:  GOTO   064
0860:  MOVF   6D,W
0861:  SUBLW  4A
0862:  BTFSS  03.2
0863:  GOTO   10E
....................             while (otop != -1 && op[otop] != '(' &&
....................                    uu_tien_toan_tu(op[otop]) >= uu_tien_toan_tu('*')) {
0864:  MOVF   69,W
0865:  SUBLW  FF
0866:  BTFSC  03.2
0867:  GOTO   107
0868:  MOVLW  C8
0869:  ADDWF  69,W
086A:  MOVWF  04
086B:  BCF    03.7
086C:  MOVF   00,W
086D:  SUBLW  28
086E:  BTFSC  03.2
086F:  GOTO   107
0870:  MOVLW  C8
0871:  ADDWF  69,W
0872:  MOVWF  04
0873:  BCF    03.7
0874:  MOVF   00,W
0875:  BSF    03.6
0876:  MOVWF  10
0877:  MOVWF  25
0878:  BCF    0A.3
0879:  BCF    03.6
087A:  CALL   2DA
087B:  BSF    0A.3
087C:  MOVF   79,W
087D:  BSF    03.6
087E:  MOVWF  11
087F:  MOVF   78,W
0880:  MOVWF  10
0881:  MOVLW  2A
0882:  MOVWF  25
0883:  BCF    0A.3
0884:  BCF    03.6
0885:  CALL   2DA
0886:  BSF    0A.3
0887:  MOVF   79,W
0888:  MOVWF  7A
0889:  MOVF   78,W
088A:  BTFSS  7A.7
088B:  GOTO   091
088C:  BSF    03.6
088D:  BTFSS  11.7
088E:  GOTO   0A4
088F:  GOTO   096
0890:  BCF    03.6
0891:  BSF    03.6
0892:  BTFSS  11.7
0893:  GOTO   096
0894:  BCF    03.6
0895:  GOTO   107
0896:  MOVF   7A,W
0897:  SUBWF  11,W
0898:  BTFSC  03.0
0899:  GOTO   09C
089A:  BCF    03.6
089B:  GOTO   107
089C:  BTFSS  03.2
089D:  GOTO   0A4
089E:  MOVF   78,W
089F:  SUBWF  10,W
08A0:  BTFSC  03.0
08A1:  GOTO   0A4
08A2:  BCF    03.6
08A3:  GOTO   107
....................                 if (vtop < 1) { loi = 1; return 0; }
08A4:  BCF    03.6
08A5:  MOVF   68,F
08A6:  BTFSS  03.2
08A7:  GOTO   0AF
08A8:  CLRF   31
08A9:  MOVLW  01
08AA:  MOVWF  30
08AB:  MOVLW  00
08AC:  MOVWF  78
08AD:  MOVWF  79
08AE:  GOTO   75F
....................                 signed long b = val[vtop--];
....................                 signed long a = val[vtop--];
08AF:  MOVF   68,W
08B0:  DECF   68,F
08B1:  MOVWF  77
08B2:  BCF    03.0
08B3:  RLF    77,F
08B4:  MOVF   77,W
08B5:  ADDLW  A0
08B6:  MOVWF  04
08B7:  BCF    03.7
08B8:  INCF   04,F
08B9:  MOVF   00,W
08BA:  MOVWF  6F
08BB:  DECF   04,F
08BC:  MOVF   00,W
08BD:  MOVWF  6E
08BE:  MOVF   68,W
08BF:  DECF   68,F
08C0:  MOVWF  77
08C1:  BCF    03.0
08C2:  RLF    77,F
08C3:  MOVF   77,W
08C4:  ADDLW  A0
08C5:  MOVWF  04
08C6:  BCF    03.7
08C7:  INCF   04,F
08C8:  MOVF   00,W
08C9:  MOVWF  71
08CA:  DECF   04,F
08CB:  MOVF   00,W
08CC:  MOVWF  70
....................                 val[++vtop] = tinh_toan(a, b, op[otop--]);
08CD:  INCF   68,F
08CE:  BCF    03.0
08CF:  RLF    68,W
08D0:  ADDLW  A0
08D1:  BSF    03.6
08D2:  MOVWF  10
08D3:  CLRF   11
08D4:  BTFSC  03.0
08D5:  INCF   11,F
08D6:  BCF    03.6
08D7:  MOVF   69,W
08D8:  DECF   69,F
08D9:  ADDLW  C8
08DA:  MOVWF  04
08DB:  BCF    03.7
08DC:  MOVF   00,W
08DD:  BSF    03.6
08DE:  MOVWF  12
08DF:  MOVF   71,W
08E0:  MOVWF  27
08E1:  MOVF   70,W
08E2:  MOVWF  26
08E3:  BCF    03.6
08E4:  MOVF   6F,W
08E5:  BSF    03.6
08E6:  MOVWF  29
08E7:  BCF    03.6
08E8:  MOVF   6E,W
08E9:  BSF    03.6
08EA:  MOVWF  28
08EB:  MOVF   12,W
08EC:  MOVWF  2A
08ED:  BCF    0A.3
08EE:  BCF    03.6
08EF:  CALL   367
08F0:  BSF    0A.3
08F1:  BSF    03.6
08F2:  MOVF   10,W
08F3:  MOVWF  04
08F4:  BCF    03.7
08F5:  BTFSC  11.0
08F6:  BSF    03.7
08F7:  INCF   04,F
08F8:  MOVF   79,W
08F9:  MOVWF  00
08FA:  DECF   04,F
08FB:  MOVF   78,W
08FC:  MOVWF  00
....................                 if (loi) return 0;
08FD:  BCF    03.6
08FE:  MOVF   30,W
08FF:  IORWF  31,W
0900:  BTFSC  03.2
0901:  GOTO   106
0902:  MOVLW  00
0903:  MOVWF  78
0904:  MOVWF  79
0905:  GOTO   75F
0906:  GOTO   064
....................             }
....................             op[++otop] = '*';
0907:  INCF   69,F
0908:  MOVLW  C8
0909:  ADDWF  69,W
090A:  MOVWF  04
090B:  BCF    03.7
090C:  MOVLW  2A
090D:  MOVWF  00
....................         }
....................     }
....................     val[++vtop] = ANS;
090E:  INCF   68,F
090F:  BCF    03.0
0910:  RLF    68,W
0911:  ADDLW  A0
0912:  MOVWF  04
0913:  BCF    03.7
0914:  INCF   04,F
0915:  MOVF   2B,W
0916:  MOVWF  00
0917:  DECF   04,F
0918:  MOVF   2A,W
0919:  MOVWF  00
....................     continue;
091A:  GOTO   6D3
.................... }
.................... 
....................         /* ===== X? L? 'I' ===== */
....................        /* ===== X? L? 'I' ===== */
.................... if (c == 'I') {
091B:  MOVF   6C,W
091C:  SUBLW  49
091D:  BTFSS  03.2
091E:  GOTO   20A
....................     // N?u trý?c I là s? ho?c ) ho?c A/I/J ? thêm phép nhân ng?m
....................     if (i > 0) {
091F:  BTFSC  6B.7
0920:  GOTO   1FD
0921:  MOVF   6B,F
0922:  BTFSS  03.2
0923:  GOTO   128
0924:  MOVF   6A,W
0925:  SUBLW  00
0926:  BTFSC  03.0
0927:  GOTO   1FD
....................         char prev = bieu_thuc[i-1];
0928:  MOVLW  01
0929:  SUBWF  6A,W
092A:  BSF    03.6
092B:  MOVWF  10
092C:  BCF    03.6
092D:  MOVF   6B,W
092E:  BSF    03.6
092F:  MOVWF  11
0930:  MOVLW  00
0931:  BTFSS  03.0
0932:  MOVLW  01
0933:  SUBWF  11,F
0934:  BCF    03.6
0935:  MOVF   66,W
0936:  BSF    03.6
0937:  ADDWF  10,W
0938:  MOVWF  04
0939:  BCF    03.7
093A:  BCF    03.6
093B:  BTFSC  67.0
093C:  BSF    03.7
093D:  MOVF   00,W
093E:  MOVWF  72
....................         if ((prev >= '0' && prev <= '9') || prev == ')' || 
....................             prev == 'A' || prev == 'I' || prev == 'J') {
093F:  MOVF   72,W
0940:  SUBLW  2F
0941:  BTFSC  03.0
0942:  GOTO   147
0943:  MOVF   72,W
0944:  SUBLW  39
0945:  BTFSC  03.0
0946:  GOTO   157
0947:  MOVF   72,W
0948:  SUBLW  29
0949:  BTFSC  03.2
094A:  GOTO   157
094B:  MOVF   72,W
094C:  SUBLW  41
094D:  BTFSC  03.2
094E:  GOTO   157
094F:  MOVF   72,W
0950:  SUBLW  49
0951:  BTFSC  03.2
0952:  GOTO   157
0953:  MOVF   72,W
0954:  SUBLW  4A
0955:  BTFSS  03.2
0956:  GOTO   1FD
....................             while (otop != -1 && op[otop] != '(' &&
....................                    uu_tien_toan_tu(op[otop]) >= uu_tien_toan_tu('*')) {
0957:  MOVF   69,W
0958:  SUBLW  FF
0959:  BTFSC  03.2
095A:  GOTO   1F6
095B:  MOVLW  C8
095C:  ADDWF  69,W
095D:  MOVWF  04
095E:  BCF    03.7
095F:  MOVF   00,W
0960:  SUBLW  28
0961:  BTFSC  03.2
0962:  GOTO   1F6
0963:  MOVLW  C8
0964:  ADDWF  69,W
0965:  MOVWF  04
0966:  BCF    03.7
0967:  MOVF   00,W
0968:  BSF    03.6
0969:  MOVWF  10
096A:  MOVWF  25
096B:  BCF    0A.3
096C:  BCF    03.6
096D:  CALL   2DA
096E:  BSF    0A.3
096F:  MOVF   79,W
0970:  BSF    03.6
0971:  MOVWF  11
0972:  MOVF   78,W
0973:  MOVWF  10
0974:  MOVLW  2A
0975:  MOVWF  25
0976:  BCF    0A.3
0977:  BCF    03.6
0978:  CALL   2DA
0979:  BSF    0A.3
097A:  MOVF   79,W
097B:  MOVWF  7A
097C:  MOVF   78,W
097D:  BTFSS  7A.7
097E:  GOTO   184
097F:  BSF    03.6
0980:  BTFSS  11.7
0981:  GOTO   197
0982:  GOTO   189
0983:  BCF    03.6
0984:  BSF    03.6
0985:  BTFSS  11.7
0986:  GOTO   189
0987:  BCF    03.6
0988:  GOTO   1F6
0989:  MOVF   7A,W
098A:  SUBWF  11,W
098B:  BTFSC  03.0
098C:  GOTO   18F
098D:  BCF    03.6
098E:  GOTO   1F6
098F:  BTFSS  03.2
0990:  GOTO   197
0991:  MOVF   78,W
0992:  SUBWF  10,W
0993:  BTFSC  03.0
0994:  GOTO   197
0995:  BCF    03.6
0996:  GOTO   1F6
....................                 if (vtop < 1) { loi = 1; return 0; }
0997:  BCF    03.6
0998:  MOVF   68,F
0999:  BTFSS  03.2
099A:  GOTO   1A2
099B:  CLRF   31
099C:  MOVLW  01
099D:  MOVWF  30
099E:  MOVLW  00
099F:  MOVWF  78
09A0:  MOVWF  79
09A1:  GOTO   75F
....................                 signed long b = val[vtop--];
....................                 signed long a = val[vtop--];
09A2:  MOVF   68,W
09A3:  DECF   68,F
09A4:  MOVWF  77
09A5:  BCF    03.0
09A6:  RLF    77,F
09A7:  MOVF   77,W
09A8:  ADDLW  A0
09A9:  MOVWF  04
09AA:  BCF    03.7
09AB:  INCF   04,F
09AC:  MOVF   00,W
09AD:  MOVWF  74
09AE:  DECF   04,F
09AF:  MOVF   00,W
09B0:  MOVWF  73
09B1:  MOVF   68,W
09B2:  DECF   68,F
09B3:  MOVWF  77
09B4:  BCF    03.0
09B5:  RLF    77,F
09B6:  MOVF   77,W
09B7:  ADDLW  A0
09B8:  MOVWF  04
09B9:  BCF    03.7
09BA:  INCF   04,F
09BB:  MOVF   00,W
09BC:  MOVWF  76
09BD:  DECF   04,F
09BE:  MOVF   00,W
09BF:  MOVWF  75
....................                 val[++vtop] = tinh_toan(a, b, op[otop--]);
09C0:  INCF   68,F
09C1:  BCF    03.0
09C2:  RLF    68,W
09C3:  ADDLW  A0
09C4:  BSF    03.6
09C5:  MOVWF  10
09C6:  CLRF   11
09C7:  BTFSC  03.0
09C8:  INCF   11,F
09C9:  BCF    03.6
09CA:  MOVF   69,W
09CB:  DECF   69,F
09CC:  ADDLW  C8
09CD:  MOVWF  04
09CE:  BCF    03.7
09CF:  MOVF   00,W
09D0:  BSF    03.6
09D1:  MOVWF  12
09D2:  MOVF   76,W
09D3:  MOVWF  27
09D4:  MOVF   75,W
09D5:  MOVWF  26
09D6:  MOVF   74,W
09D7:  MOVWF  29
09D8:  MOVF   73,W
09D9:  MOVWF  28
09DA:  MOVF   12,W
09DB:  MOVWF  2A
09DC:  BCF    0A.3
09DD:  BCF    03.6
09DE:  CALL   367
09DF:  BSF    0A.3
09E0:  BSF    03.6
09E1:  MOVF   10,W
09E2:  MOVWF  04
09E3:  BCF    03.7
09E4:  BTFSC  11.0
09E5:  BSF    03.7
09E6:  INCF   04,F
09E7:  MOVF   79,W
09E8:  MOVWF  00
09E9:  DECF   04,F
09EA:  MOVF   78,W
09EB:  MOVWF  00
....................                 if (loi) return 0;
09EC:  BCF    03.6
09ED:  MOVF   30,W
09EE:  IORWF  31,W
09EF:  BTFSC  03.2
09F0:  GOTO   1F5
09F1:  MOVLW  00
09F2:  MOVWF  78
09F3:  MOVWF  79
09F4:  GOTO   75F
09F5:  GOTO   157
....................             }
....................             op[++otop] = '*';
09F6:  INCF   69,F
09F7:  MOVLW  C8
09F8:  ADDWF  69,W
09F9:  MOVWF  04
09FA:  BCF    03.7
09FB:  MOVLW  2A
09FC:  MOVWF  00
....................         }
....................     }
....................     val[++vtop] = luu_gia_tri_I;
09FD:  INCF   68,F
09FE:  BCF    03.0
09FF:  RLF    68,W
0A00:  ADDLW  A0
0A01:  MOVWF  04
0A02:  BCF    03.7
0A03:  INCF   04,F
0A04:  MOVF   2D,W
0A05:  MOVWF  00
0A06:  DECF   04,F
0A07:  MOVF   2C,W
0A08:  MOVWF  00
....................     continue;
0A09:  GOTO   6D3
.................... }
.................... 
....................         /* ===== X? L? 'J' ===== */
....................        /* ===== X? L? 'J' ===== */
.................... if (c == 'J') {
0A0A:  MOVF   6C,W
0A0B:  SUBLW  4A
0A0C:  BTFSS  03.2
0A0D:  GOTO   303
....................     // N?u trý?c J là s? ho?c ) ho?c A/I/J ? thêm phép nhân ng?m
....................     if (i > 0) {
0A0E:  BTFSC  6B.7
0A0F:  GOTO   2F6
0A10:  MOVF   6B,F
0A11:  BTFSS  03.2
0A12:  GOTO   217
0A13:  MOVF   6A,W
0A14:  SUBLW  00
0A15:  BTFSC  03.0
0A16:  GOTO   2F6
....................         char prev = bieu_thuc[i-1];
0A17:  MOVLW  01
0A18:  SUBWF  6A,W
0A19:  BSF    03.6
0A1A:  MOVWF  10
0A1B:  BCF    03.6
0A1C:  MOVF   6B,W
0A1D:  BSF    03.6
0A1E:  MOVWF  11
0A1F:  MOVLW  00
0A20:  BTFSS  03.0
0A21:  MOVLW  01
0A22:  SUBWF  11,F
0A23:  BCF    03.6
0A24:  MOVF   66,W
0A25:  BSF    03.6
0A26:  ADDWF  10,W
0A27:  MOVWF  04
0A28:  BCF    03.7
0A29:  BCF    03.6
0A2A:  BTFSC  67.0
0A2B:  BSF    03.7
0A2C:  MOVF   00,W
0A2D:  MOVWF  7B
....................         if ((prev >= '0' && prev <= '9') || prev == ')' || 
....................             prev == 'A' || prev == 'I' || prev == 'J') {
0A2E:  MOVF   7B,W
0A2F:  SUBLW  2F
0A30:  BTFSC  03.0
0A31:  GOTO   236
0A32:  MOVF   7B,W
0A33:  SUBLW  39
0A34:  BTFSC  03.0
0A35:  GOTO   246
0A36:  MOVF   7B,W
0A37:  SUBLW  29
0A38:  BTFSC  03.2
0A39:  GOTO   246
0A3A:  MOVF   7B,W
0A3B:  SUBLW  41
0A3C:  BTFSC  03.2
0A3D:  GOTO   246
0A3E:  MOVF   7B,W
0A3F:  SUBLW  49
0A40:  BTFSC  03.2
0A41:  GOTO   246
0A42:  MOVF   7B,W
0A43:  SUBLW  4A
0A44:  BTFSS  03.2
0A45:  GOTO   2F6
....................             while (otop != -1 && op[otop] != '(' &&
....................                    uu_tien_toan_tu(op[otop]) >= uu_tien_toan_tu('*')) {
0A46:  MOVF   69,W
0A47:  SUBLW  FF
0A48:  BTFSC  03.2
0A49:  GOTO   2EF
0A4A:  MOVLW  C8
0A4B:  ADDWF  69,W
0A4C:  MOVWF  04
0A4D:  BCF    03.7
0A4E:  MOVF   00,W
0A4F:  SUBLW  28
0A50:  BTFSC  03.2
0A51:  GOTO   2EF
0A52:  MOVLW  C8
0A53:  ADDWF  69,W
0A54:  MOVWF  04
0A55:  BCF    03.7
0A56:  MOVF   00,W
0A57:  BSF    03.6
0A58:  MOVWF  10
0A59:  MOVWF  25
0A5A:  BCF    0A.3
0A5B:  BCF    03.6
0A5C:  CALL   2DA
0A5D:  BSF    0A.3
0A5E:  MOVF   79,W
0A5F:  BSF    03.6
0A60:  MOVWF  11
0A61:  MOVF   78,W
0A62:  MOVWF  10
0A63:  MOVLW  2A
0A64:  MOVWF  25
0A65:  BCF    0A.3
0A66:  BCF    03.6
0A67:  CALL   2DA
0A68:  BSF    0A.3
0A69:  MOVF   79,W
0A6A:  MOVWF  7A
0A6B:  MOVF   78,W
0A6C:  BTFSS  7A.7
0A6D:  GOTO   273
0A6E:  BSF    03.6
0A6F:  BTFSS  11.7
0A70:  GOTO   286
0A71:  GOTO   278
0A72:  BCF    03.6
0A73:  BSF    03.6
0A74:  BTFSS  11.7
0A75:  GOTO   278
0A76:  BCF    03.6
0A77:  GOTO   2EF
0A78:  MOVF   7A,W
0A79:  SUBWF  11,W
0A7A:  BTFSC  03.0
0A7B:  GOTO   27E
0A7C:  BCF    03.6
0A7D:  GOTO   2EF
0A7E:  BTFSS  03.2
0A7F:  GOTO   286
0A80:  MOVF   78,W
0A81:  SUBWF  10,W
0A82:  BTFSC  03.0
0A83:  GOTO   286
0A84:  BCF    03.6
0A85:  GOTO   2EF
....................                 if (vtop < 1) { loi = 1; return 0; }
0A86:  BCF    03.6
0A87:  MOVF   68,F
0A88:  BTFSS  03.2
0A89:  GOTO   291
0A8A:  CLRF   31
0A8B:  MOVLW  01
0A8C:  MOVWF  30
0A8D:  MOVLW  00
0A8E:  MOVWF  78
0A8F:  MOVWF  79
0A90:  GOTO   75F
....................                 signed long b = val[vtop--];
....................                 signed long a = val[vtop--];
0A91:  MOVF   68,W
0A92:  DECF   68,F
0A93:  MOVWF  77
0A94:  BCF    03.0
0A95:  RLF    77,F
0A96:  MOVF   77,W
0A97:  ADDLW  A0
0A98:  MOVWF  04
0A99:  BCF    03.7
0A9A:  INCF   04,F
0A9B:  MOVF   00,W
0A9C:  MOVWF  7D
0A9D:  DECF   04,F
0A9E:  MOVF   00,W
0A9F:  MOVWF  7C
0AA0:  MOVF   68,W
0AA1:  DECF   68,F
0AA2:  MOVWF  77
0AA3:  BCF    03.0
0AA4:  RLF    77,F
0AA5:  MOVF   77,W
0AA6:  ADDLW  A0
0AA7:  MOVWF  04
0AA8:  BCF    03.7
0AA9:  INCF   04,F
0AAA:  MOVF   00,W
0AAB:  BSF    03.5
0AAC:  MOVWF  5D
0AAD:  DECF   04,F
0AAE:  MOVF   00,W
0AAF:  MOVWF  5C
....................                 val[++vtop] = tinh_toan(a, b, op[otop--]);
0AB0:  BCF    03.5
0AB1:  INCF   68,F
0AB2:  BCF    03.0
0AB3:  RLF    68,W
0AB4:  ADDLW  A0
0AB5:  BSF    03.6
0AB6:  MOVWF  10
0AB7:  CLRF   11
0AB8:  BTFSC  03.0
0AB9:  INCF   11,F
0ABA:  BCF    03.6
0ABB:  MOVF   69,W
0ABC:  DECF   69,F
0ABD:  ADDLW  C8
0ABE:  MOVWF  04
0ABF:  BCF    03.7
0AC0:  MOVF   00,W
0AC1:  BSF    03.6
0AC2:  MOVWF  12
0AC3:  BSF    03.5
0AC4:  BCF    03.6
0AC5:  MOVF   5D,W
0AC6:  BCF    03.5
0AC7:  BSF    03.6
0AC8:  MOVWF  27
0AC9:  BSF    03.5
0ACA:  BCF    03.6
0ACB:  MOVF   5C,W
0ACC:  BCF    03.5
0ACD:  BSF    03.6
0ACE:  MOVWF  26
0ACF:  MOVF   7D,W
0AD0:  MOVWF  29
0AD1:  MOVF   7C,W
0AD2:  MOVWF  28
0AD3:  MOVF   12,W
0AD4:  MOVWF  2A
0AD5:  BCF    0A.3
0AD6:  BCF    03.6
0AD7:  CALL   367
0AD8:  BSF    0A.3
0AD9:  BSF    03.6
0ADA:  MOVF   10,W
0ADB:  MOVWF  04
0ADC:  BCF    03.7
0ADD:  BTFSC  11.0
0ADE:  BSF    03.7
0ADF:  INCF   04,F
0AE0:  MOVF   79,W
0AE1:  MOVWF  00
0AE2:  DECF   04,F
0AE3:  MOVF   78,W
0AE4:  MOVWF  00
....................                 if (loi) return 0;
0AE5:  BCF    03.6
0AE6:  MOVF   30,W
0AE7:  IORWF  31,W
0AE8:  BTFSC  03.2
0AE9:  GOTO   2EE
0AEA:  MOVLW  00
0AEB:  MOVWF  78
0AEC:  MOVWF  79
0AED:  GOTO   75F
0AEE:  GOTO   246
....................             }
....................             op[++otop] = '*';
0AEF:  INCF   69,F
0AF0:  MOVLW  C8
0AF1:  ADDWF  69,W
0AF2:  MOVWF  04
0AF3:  BCF    03.7
0AF4:  MOVLW  2A
0AF5:  MOVWF  00
....................         }
....................     }
....................     val[++vtop] = luu_gia_tri_J;
0AF6:  INCF   68,F
0AF7:  BCF    03.0
0AF8:  RLF    68,W
0AF9:  ADDLW  A0
0AFA:  MOVWF  04
0AFB:  BCF    03.7
0AFC:  INCF   04,F
0AFD:  MOVF   2F,W
0AFE:  MOVWF  00
0AFF:  DECF   04,F
0B00:  MOVF   2E,W
0B01:  MOVWF  00
....................     continue;
0B02:  GOTO   6D3
.................... }
.................... 
....................         /* ===== TOÁN T? ÐÕN '-' ===== */
....................         if (c == '-' && (i == 0 || bieu_thuc[i-1] == '(' || phep_toan(bieu_thuc[i-1]))) {
0B03:  MOVF   6C,W
0B04:  SUBLW  2D
0B05:  BTFSS  03.2
0B06:  GOTO   359
0B07:  MOVF   6A,F
0B08:  BTFSS  03.2
0B09:  GOTO   30D
0B0A:  MOVF   6B,F
0B0B:  BTFSC  03.2
0B0C:  GOTO   347
0B0D:  MOVLW  01
0B0E:  SUBWF  6A,W
0B0F:  BSF    03.6
0B10:  MOVWF  10
0B11:  BCF    03.6
0B12:  MOVF   6B,W
0B13:  BSF    03.6
0B14:  MOVWF  11
0B15:  MOVLW  00
0B16:  BTFSS  03.0
0B17:  MOVLW  01
0B18:  SUBWF  11,F
0B19:  BCF    03.6
0B1A:  MOVF   66,W
0B1B:  BSF    03.6
0B1C:  ADDWF  10,W
0B1D:  MOVWF  04
0B1E:  BCF    03.7
0B1F:  BCF    03.6
0B20:  BTFSC  67.0
0B21:  BSF    03.7
0B22:  MOVF   00,W
0B23:  SUBLW  28
0B24:  BTFSC  03.2
0B25:  GOTO   347
0B26:  MOVLW  01
0B27:  SUBWF  6A,W
0B28:  BSF    03.6
0B29:  MOVWF  12
0B2A:  BCF    03.6
0B2B:  MOVF   6B,W
0B2C:  BSF    03.6
0B2D:  MOVWF  13
0B2E:  MOVLW  00
0B2F:  BTFSS  03.0
0B30:  MOVLW  01
0B31:  SUBWF  13,F
0B32:  BCF    03.6
0B33:  MOVF   66,W
0B34:  BSF    03.6
0B35:  ADDWF  12,W
0B36:  MOVWF  04
0B37:  BCF    03.7
0B38:  BCF    03.6
0B39:  BTFSC  67.0
0B3A:  BSF    03.7
0B3B:  MOVF   00,W
0B3C:  BSF    03.6
0B3D:  MOVWF  14
0B3E:  MOVWF  28
0B3F:  BCF    0A.3
0B40:  BCF    03.6
0B41:  CALL   4F6
0B42:  BSF    0A.3
0B43:  MOVF   78,W
0B44:  IORWF  79,W
0B45:  BTFSC  03.2
0B46:  GOTO   359
....................             val[++vtop] = 0;
0B47:  INCF   68,F
0B48:  BCF    03.0
0B49:  RLF    68,W
0B4A:  ADDLW  A0
0B4B:  MOVWF  04
0B4C:  BCF    03.7
0B4D:  INCF   04,F
0B4E:  CLRF   00
0B4F:  DECF   04,F
0B50:  CLRF   00
....................             op[++otop] = '-';
0B51:  INCF   69,F
0B52:  MOVLW  C8
0B53:  ADDWF  69,W
0B54:  MOVWF  04
0B55:  BCF    03.7
0B56:  MOVLW  2D
0B57:  MOVWF  00
....................             continue;
0B58:  GOTO   6D3
....................         }
.................... 
....................         /* ===== S? ===== */
....................         if (c >= '0' && c <= '9') {
0B59:  MOVF   6C,W
0B5A:  SUBLW  2F
0B5B:  BTFSC  03.0
0B5C:  GOTO   3D2
0B5D:  MOVF   6C,W
0B5E:  SUBLW  39
0B5F:  BTFSS  03.0
0B60:  GOTO   3D2
....................             signed long num = 0;
0B61:  BSF    03.5
0B62:  CLRF   5F
0B63:  CLRF   5E
....................             while (i < strlen(bieu_thuc) && bieu_thuc[i] >= '0' && bieu_thuc[i] <= '9') {
0B64:  BCF    03.5
0B65:  MOVF   67,W
0B66:  BSF    03.6
0B67:  MOVWF  26
0B68:  BCF    03.6
0B69:  MOVF   66,W
0B6A:  BSF    03.6
0B6B:  MOVWF  25
0B6C:  BCF    0A.3
0B6D:  BCF    03.6
0B6E:  CALL   2BA
0B6F:  BSF    0A.3
0B70:  BTFSC  6B.7
0B71:  GOTO   379
0B72:  MOVF   6B,F
0B73:  BTFSS  03.2
0B74:  GOTO   3BF
0B75:  MOVF   78,W
0B76:  SUBWF  6A,W
0B77:  BTFSC  03.0
0B78:  GOTO   3BF
0B79:  MOVF   66,W
0B7A:  ADDWF  6A,W
0B7B:  MOVWF  04
0B7C:  BCF    03.7
0B7D:  BTFSC  67.0
0B7E:  BSF    03.7
0B7F:  MOVF   00,W
0B80:  SUBLW  2F
0B81:  BTFSC  03.0
0B82:  GOTO   3BF
0B83:  MOVF   66,W
0B84:  ADDWF  6A,W
0B85:  MOVWF  04
0B86:  BCF    03.7
0B87:  BTFSC  67.0
0B88:  BSF    03.7
0B89:  MOVF   00,W
0B8A:  SUBLW  39
0B8B:  BTFSS  03.0
0B8C:  GOTO   3BF
....................                 num = num * 10 + (bieu_thuc[i] - '0');
0B8D:  BSF    03.5
0B8E:  MOVF   5F,W
0B8F:  BCF    03.5
0B90:  BSF    03.6
0B91:  MOVWF  34
0B92:  BSF    03.5
0B93:  BCF    03.6
0B94:  MOVF   5E,W
0B95:  BCF    03.5
0B96:  BSF    03.6
0B97:  MOVWF  33
0B98:  CLRF   36
0B99:  MOVLW  0A
0B9A:  MOVWF  35
0B9B:  BCF    0A.3
0B9C:  BCF    03.6
0B9D:  CALL   337
0B9E:  BSF    0A.3
0B9F:  MOVF   79,W
0BA0:  BSF    03.6
0BA1:  MOVWF  11
0BA2:  MOVF   78,W
0BA3:  MOVWF  10
0BA4:  BCF    03.6
0BA5:  MOVF   66,W
0BA6:  ADDWF  6A,W
0BA7:  MOVWF  04
0BA8:  BCF    03.7
0BA9:  BTFSC  67.0
0BAA:  BSF    03.7
0BAB:  MOVLW  30
0BAC:  SUBWF  00,W
0BAD:  BSF    03.6
0BAE:  ADDWF  10,W
0BAF:  BSF    03.5
0BB0:  BCF    03.6
0BB1:  MOVWF  5E
0BB2:  BCF    03.5
0BB3:  BSF    03.6
0BB4:  MOVF   11,W
0BB5:  BSF    03.5
0BB6:  BCF    03.6
0BB7:  MOVWF  5F
0BB8:  BTFSC  03.0
0BB9:  INCF   5F,F
....................                 i++;
0BBA:  BCF    03.5
0BBB:  INCF   6A,F
0BBC:  BTFSC  03.2
0BBD:  INCF   6B,F
0BBE:  GOTO   365
....................             }
....................             val[++vtop] = num;
0BBF:  INCF   68,F
0BC0:  BCF    03.0
0BC1:  RLF    68,W
0BC2:  ADDLW  A0
0BC3:  MOVWF  04
0BC4:  BCF    03.7
0BC5:  INCF   04,F
0BC6:  BSF    03.5
0BC7:  MOVF   5F,W
0BC8:  MOVWF  00
0BC9:  DECF   04,F
0BCA:  MOVF   5E,W
0BCB:  MOVWF  00
....................             i--;
0BCC:  BCF    03.5
0BCD:  MOVF   6A,W
0BCE:  BTFSC  03.2
0BCF:  DECF   6B,F
0BD0:  DECF   6A,F
....................         }
0BD1:  GOTO   6D3
.................... 
....................         /* ===== NGO?C ===== */
....................         else if (c == '(') {
0BD2:  MOVF   6C,W
0BD3:  SUBLW  28
0BD4:  BTFSS  03.2
0BD5:  GOTO   3DE
....................             op[++otop] = '(';
0BD6:  INCF   69,F
0BD7:  MOVLW  C8
0BD8:  ADDWF  69,W
0BD9:  MOVWF  04
0BDA:  BCF    03.7
0BDB:  MOVLW  28
0BDC:  MOVWF  00
....................         }
0BDD:  GOTO   6D3
....................         else if (c == ')') {
0BDE:  MOVF   6C,W
0BDF:  SUBLW  29
0BE0:  BTFSS  03.2
0BE1:  GOTO   4B8
....................             while (otop != -1 && op[otop] != '(') {
0BE2:  MOVF   69,W
0BE3:  SUBLW  FF
0BE4:  BTFSC  03.2
0BE5:  GOTO   460
0BE6:  MOVLW  C8
0BE7:  ADDWF  69,W
0BE8:  MOVWF  04
0BE9:  BCF    03.7
0BEA:  MOVF   00,W
0BEB:  SUBLW  28
0BEC:  BTFSC  03.2
0BED:  GOTO   460
....................                 if (vtop < 1) { loi = 1; return 0; }
0BEE:  MOVF   68,F
0BEF:  BTFSS  03.2
0BF0:  GOTO   3F8
0BF1:  CLRF   31
0BF2:  MOVLW  01
0BF3:  MOVWF  30
0BF4:  MOVLW  00
0BF5:  MOVWF  78
0BF6:  MOVWF  79
0BF7:  GOTO   75F
....................                 signed long b = val[vtop--];
....................                 signed long a = val[vtop--];
0BF8:  MOVF   68,W
0BF9:  DECF   68,F
0BFA:  MOVWF  77
0BFB:  BCF    03.0
0BFC:  RLF    77,F
0BFD:  MOVF   77,W
0BFE:  ADDLW  A0
0BFF:  MOVWF  04
0C00:  BCF    03.7
0C01:  INCF   04,F
0C02:  MOVF   00,W
0C03:  BSF    03.5
0C04:  MOVWF  61
0C05:  DECF   04,F
0C06:  MOVF   00,W
0C07:  MOVWF  60
0C08:  BCF    03.5
0C09:  MOVF   68,W
0C0A:  DECF   68,F
0C0B:  MOVWF  77
0C0C:  BCF    03.0
0C0D:  RLF    77,F
0C0E:  MOVF   77,W
0C0F:  ADDLW  A0
0C10:  MOVWF  04
0C11:  BCF    03.7
0C12:  INCF   04,F
0C13:  MOVF   00,W
0C14:  BSF    03.5
0C15:  MOVWF  63
0C16:  DECF   04,F
0C17:  MOVF   00,W
0C18:  MOVWF  62
....................                 val[++vtop] = tinh_toan(a, b, op[otop--]);
0C19:  BCF    03.5
0C1A:  INCF   68,F
0C1B:  BCF    03.0
0C1C:  RLF    68,W
0C1D:  ADDLW  A0
0C1E:  BSF    03.6
0C1F:  MOVWF  10
0C20:  CLRF   11
0C21:  BTFSC  03.0
0C22:  INCF   11,F
0C23:  BCF    03.6
0C24:  MOVF   69,W
0C25:  DECF   69,F
0C26:  ADDLW  C8
0C27:  MOVWF  04
0C28:  BCF    03.7
0C29:  MOVF   00,W
0C2A:  BSF    03.6
0C2B:  MOVWF  12
0C2C:  BSF    03.5
0C2D:  BCF    03.6
0C2E:  MOVF   63,W
0C2F:  BCF    03.5
0C30:  BSF    03.6
0C31:  MOVWF  27
0C32:  BSF    03.5
0C33:  BCF    03.6
0C34:  MOVF   62,W
0C35:  BCF    03.5
0C36:  BSF    03.6
0C37:  MOVWF  26
0C38:  BSF    03.5
0C39:  BCF    03.6
0C3A:  MOVF   61,W
0C3B:  BCF    03.5
0C3C:  BSF    03.6
0C3D:  MOVWF  29
0C3E:  BSF    03.5
0C3F:  BCF    03.6
0C40:  MOVF   60,W
0C41:  BCF    03.5
0C42:  BSF    03.6
0C43:  MOVWF  28
0C44:  MOVF   12,W
0C45:  MOVWF  2A
0C46:  BCF    0A.3
0C47:  BCF    03.6
0C48:  CALL   367
0C49:  BSF    0A.3
0C4A:  BSF    03.6
0C4B:  MOVF   10,W
0C4C:  MOVWF  04
0C4D:  BCF    03.7
0C4E:  BTFSC  11.0
0C4F:  BSF    03.7
0C50:  INCF   04,F
0C51:  MOVF   79,W
0C52:  MOVWF  00
0C53:  DECF   04,F
0C54:  MOVF   78,W
0C55:  MOVWF  00
....................                 if (loi) return 0;
0C56:  BCF    03.6
0C57:  MOVF   30,W
0C58:  IORWF  31,W
0C59:  BTFSC  03.2
0C5A:  GOTO   45F
0C5B:  MOVLW  00
0C5C:  MOVWF  78
0C5D:  MOVWF  79
0C5E:  GOTO   75F
0C5F:  GOTO   3E2
....................             }
....................             if (otop == -1) { loi = 1; return 0; }
0C60:  MOVF   69,W
0C61:  SUBLW  FF
0C62:  BTFSS  03.2
0C63:  GOTO   46B
0C64:  CLRF   31
0C65:  MOVLW  01
0C66:  MOVWF  30
0C67:  MOVLW  00
0C68:  MOVWF  78
0C69:  MOVWF  79
0C6A:  GOTO   75F
....................             otop--;
0C6B:  DECF   69,F
....................             
....................             // N?u sau ) là A, I, ho?c J ? thêm phép nhân
....................             if (i+1 < strlen(bieu_thuc)) {
0C6C:  MOVLW  01
0C6D:  ADDWF  6A,W
0C6E:  BSF    03.6
0C6F:  MOVWF  10
0C70:  BCF    03.6
0C71:  MOVF   6B,W
0C72:  BSF    03.6
0C73:  MOVWF  11
0C74:  BTFSC  03.0
0C75:  INCF   11,F
0C76:  BCF    03.6
0C77:  MOVF   67,W
0C78:  BSF    03.6
0C79:  MOVWF  26
0C7A:  BCF    03.6
0C7B:  MOVF   66,W
0C7C:  BSF    03.6
0C7D:  MOVWF  25
0C7E:  BCF    0A.3
0C7F:  BCF    03.6
0C80:  CALL   2BA
0C81:  BSF    0A.3
0C82:  BSF    03.6
0C83:  BTFSC  11.7
0C84:  GOTO   48C
0C85:  MOVF   11,F
0C86:  BTFSS  03.2
0C87:  GOTO   4B6
0C88:  MOVF   78,W
0C89:  SUBWF  10,W
0C8A:  BTFSC  03.0
0C8B:  GOTO   4B6
....................                 char next = bieu_thuc[i+1];
0C8C:  MOVLW  01
0C8D:  BCF    03.6
0C8E:  ADDWF  6A,W
0C8F:  BSF    03.6
0C90:  MOVWF  10
0C91:  BCF    03.6
0C92:  MOVF   6B,W
0C93:  BSF    03.6
0C94:  MOVWF  11
0C95:  BTFSC  03.0
0C96:  INCF   11,F
0C97:  BCF    03.6
0C98:  MOVF   66,W
0C99:  BSF    03.6
0C9A:  ADDWF  10,W
0C9B:  MOVWF  04
0C9C:  BCF    03.7
0C9D:  BCF    03.6
0C9E:  BTFSC  67.0
0C9F:  BSF    03.7
0CA0:  MOVF   00,W
0CA1:  MOVWF  7E
....................                 if (next == 'A' || next == 'I' || next == 'J') {
0CA2:  MOVF   7E,W
0CA3:  SUBLW  41
0CA4:  BTFSC  03.2
0CA5:  GOTO   4AE
0CA6:  MOVF   7E,W
0CA7:  SUBLW  49
0CA8:  BTFSC  03.2
0CA9:  GOTO   4AE
0CAA:  MOVF   7E,W
0CAB:  SUBLW  4A
0CAC:  BTFSS  03.2
0CAD:  GOTO   4B5
....................                     op[++otop] = '*';
0CAE:  INCF   69,F
0CAF:  MOVLW  C8
0CB0:  ADDWF  69,W
0CB1:  MOVWF  04
0CB2:  BCF    03.7
0CB3:  MOVLW  2A
0CB4:  MOVWF  00
0CB5:  BSF    03.6
....................                 }
....................             }
....................         }
0CB6:  GOTO   6D4
0CB7:  BCF    03.6
.................... 
....................         /* ===== GIAI TH?A ===== */
....................         else if (c == '!') {
0CB8:  MOVF   6C,W
0CB9:  SUBLW  21
0CBA:  BTFSS  03.2
0CBB:  GOTO   54C
....................             if (vtop < 0) {
....................                 loi = 1;
....................                 return 0;
....................             }
....................             if (val[vtop] < 0) {
0CBC:  BCF    03.0
0CBD:  RLF    68,W
0CBE:  ADDLW  A0
0CBF:  MOVWF  04
0CC0:  BCF    03.7
0CC1:  INCF   04,F
0CC2:  MOVF   00,W
0CC3:  BSF    03.6
0CC4:  MOVWF  11
0CC5:  DECF   04,F
0CC6:  MOVF   00,W
0CC7:  MOVWF  10
0CC8:  BTFSC  11.7
0CC9:  GOTO   4CB
0CCA:  GOTO   4D4
....................                 loi = 1;
0CCB:  BCF    03.6
0CCC:  CLRF   31
0CCD:  MOVLW  01
0CCE:  MOVWF  30
....................                 return 0;
0CCF:  MOVLW  00
0CD0:  MOVWF  78
0CD1:  MOVWF  79
0CD2:  GOTO   75F
0CD3:  BSF    03.6
....................             }
....................             val[vtop] = tinh_giai_thua(val[vtop]);
0CD4:  BCF    03.0
0CD5:  BCF    03.6
0CD6:  RLF    68,W
0CD7:  ADDLW  A0
0CD8:  BSF    03.6
0CD9:  MOVWF  10
0CDA:  CLRF   11
0CDB:  BTFSC  03.0
0CDC:  INCF   11,F
0CDD:  BCF    03.0
0CDE:  BCF    03.6
0CDF:  RLF    68,W
0CE0:  ADDLW  A0
0CE1:  MOVWF  04
0CE2:  BCF    03.7
0CE3:  INCF   04,F
0CE4:  MOVF   00,W
0CE5:  BSF    03.6
0CE6:  MOVWF  13
0CE7:  DECF   04,F
0CE8:  MOVF   00,W
0CE9:  MOVWF  12
0CEA:  MOVF   13,W
0CEB:  MOVWF  28
0CEC:  MOVF   12,W
0CED:  MOVWF  27
*
0D37:  MOVF   10,W
0D38:  MOVWF  04
0D39:  BCF    03.7
0D3A:  BTFSC  11.0
0D3B:  BSF    03.7
0D3C:  INCF   04,F
0D3D:  MOVF   79,W
0D3E:  MOVWF  00
0D3F:  DECF   04,F
0D40:  MOVF   78,W
0D41:  MOVWF  00
....................             if (loi) return 0;
0D42:  BCF    03.6
0D43:  MOVF   30,W
0D44:  IORWF  31,W
0D45:  BTFSC  03.2
0D46:  GOTO   54B
0D47:  MOVLW  00
0D48:  MOVWF  78
0D49:  MOVWF  79
0D4A:  GOTO   75F
....................         }
0D4B:  GOTO   6D3
.................... 
....................         /* ===== TOÁN T? ===== */
....................         else if (phep_toan(c)) {
0D4C:  MOVF   6C,W
0D4D:  BSF    03.6
0D4E:  MOVWF  28
0D4F:  BCF    0A.3
0D50:  BCF    03.6
0D51:  CALL   4F6
0D52:  BSF    0A.3
0D53:  MOVF   78,W
0D54:  IORWF  79,W
0D55:  BTFSC  03.2
0D56:  GOTO   6CC
....................             if (c == '^') {
0D57:  MOVF   6C,W
0D58:  SUBLW  5E
0D59:  BTFSS  03.2
0D5A:  GOTO   60F
....................                 while (otop != -1 && op[otop] != '(' &&
....................                        uu_tien_toan_tu(op[otop]) > uu_tien_toan_tu('^')) {
0D5B:  MOVF   69,W
0D5C:  SUBLW  FF
0D5D:  BTFSC  03.2
0D5E:  GOTO   60E
0D5F:  MOVLW  C8
0D60:  ADDWF  69,W
0D61:  MOVWF  04
0D62:  BCF    03.7
0D63:  MOVF   00,W
0D64:  SUBLW  28
0D65:  BTFSC  03.2
0D66:  GOTO   60E
0D67:  MOVLW  C8
0D68:  ADDWF  69,W
0D69:  MOVWF  04
0D6A:  BCF    03.7
0D6B:  MOVF   00,W
0D6C:  BSF    03.6
0D6D:  MOVWF  10
0D6E:  MOVWF  25
0D6F:  BCF    0A.3
0D70:  BCF    03.6
0D71:  CALL   2DA
0D72:  BSF    0A.3
0D73:  MOVF   79,W
0D74:  BSF    03.6
0D75:  MOVWF  11
0D76:  MOVF   78,W
0D77:  MOVWF  10
0D78:  MOVLW  5E
0D79:  MOVWF  25
0D7A:  BCF    0A.3
0D7B:  BCF    03.6
0D7C:  CALL   2DA
0D7D:  BSF    0A.3
0D7E:  MOVF   79,W
0D7F:  MOVWF  7A
0D80:  MOVF   78,W
0D81:  BTFSS  7A.7
0D82:  GOTO   588
0D83:  BSF    03.6
0D84:  BTFSS  11.7
0D85:  GOTO   59B
0D86:  GOTO   58D
0D87:  BCF    03.6
0D88:  BSF    03.6
0D89:  BTFSS  11.7
0D8A:  GOTO   58D
0D8B:  BCF    03.6
0D8C:  GOTO   60E
0D8D:  MOVF   7A,W
0D8E:  SUBWF  11,W
0D8F:  BTFSC  03.0
0D90:  GOTO   593
0D91:  BCF    03.6
0D92:  GOTO   60E
0D93:  BTFSS  03.2
0D94:  GOTO   59B
0D95:  MOVF   10,W
0D96:  SUBWF  78,W
0D97:  BTFSS  03.0
0D98:  GOTO   59B
0D99:  BCF    03.6
0D9A:  GOTO   60E
....................                     if (vtop < 1) { loi = 1; return 0; }
0D9B:  BCF    03.6
0D9C:  MOVF   68,F
0D9D:  BTFSS  03.2
0D9E:  GOTO   5A6
0D9F:  CLRF   31
0DA0:  MOVLW  01
0DA1:  MOVWF  30
0DA2:  MOVLW  00
0DA3:  MOVWF  78
0DA4:  MOVWF  79
0DA5:  GOTO   75F
....................                     signed long b = val[vtop--];
....................                     signed long a = val[vtop--];
0DA6:  MOVF   68,W
0DA7:  DECF   68,F
0DA8:  MOVWF  77
0DA9:  BCF    03.0
0DAA:  RLF    77,F
0DAB:  MOVF   77,W
0DAC:  ADDLW  A0
0DAD:  MOVWF  04
0DAE:  BCF    03.7
0DAF:  INCF   04,F
0DB0:  MOVF   00,W
0DB1:  BSF    03.5
0DB2:  MOVWF  65
0DB3:  DECF   04,F
0DB4:  MOVF   00,W
0DB5:  MOVWF  64
0DB6:  BCF    03.5
0DB7:  MOVF   68,W
0DB8:  DECF   68,F
0DB9:  MOVWF  77
0DBA:  BCF    03.0
0DBB:  RLF    77,F
0DBC:  MOVF   77,W
0DBD:  ADDLW  A0
0DBE:  MOVWF  04
0DBF:  BCF    03.7
0DC0:  INCF   04,F
0DC1:  MOVF   00,W
0DC2:  BSF    03.5
0DC3:  MOVWF  67
0DC4:  DECF   04,F
0DC5:  MOVF   00,W
0DC6:  MOVWF  66
....................                     val[++vtop] = tinh_toan(a, b, op[otop--]);
0DC7:  BCF    03.5
0DC8:  INCF   68,F
0DC9:  BCF    03.0
0DCA:  RLF    68,W
0DCB:  ADDLW  A0
0DCC:  BSF    03.6
0DCD:  MOVWF  10
0DCE:  CLRF   11
0DCF:  BTFSC  03.0
0DD0:  INCF   11,F
0DD1:  BCF    03.6
0DD2:  MOVF   69,W
0DD3:  DECF   69,F
0DD4:  ADDLW  C8
0DD5:  MOVWF  04
0DD6:  BCF    03.7
0DD7:  MOVF   00,W
0DD8:  BSF    03.6
0DD9:  MOVWF  12
0DDA:  BSF    03.5
0DDB:  BCF    03.6
0DDC:  MOVF   67,W
0DDD:  BCF    03.5
0DDE:  BSF    03.6
0DDF:  MOVWF  27
0DE0:  BSF    03.5
0DE1:  BCF    03.6
0DE2:  MOVF   66,W
0DE3:  BCF    03.5
0DE4:  BSF    03.6
0DE5:  MOVWF  26
0DE6:  BSF    03.5
0DE7:  BCF    03.6
0DE8:  MOVF   65,W
0DE9:  BCF    03.5
0DEA:  BSF    03.6
0DEB:  MOVWF  29
0DEC:  BSF    03.5
0DED:  BCF    03.6
0DEE:  MOVF   64,W
0DEF:  BCF    03.5
0DF0:  BSF    03.6
0DF1:  MOVWF  28
0DF2:  MOVF   12,W
0DF3:  MOVWF  2A
0DF4:  BCF    0A.3
0DF5:  BCF    03.6
0DF6:  CALL   367
0DF7:  BSF    0A.3
0DF8:  BSF    03.6
0DF9:  MOVF   10,W
0DFA:  MOVWF  04
0DFB:  BCF    03.7
0DFC:  BTFSC  11.0
0DFD:  BSF    03.7
0DFE:  INCF   04,F
0DFF:  MOVF   79,W
0E00:  MOVWF  00
0E01:  DECF   04,F
0E02:  MOVF   78,W
0E03:  MOVWF  00
....................                     if (loi) return 0;
0E04:  BCF    03.6
0E05:  MOVF   30,W
0E06:  IORWF  31,W
0E07:  BTFSC  03.2
0E08:  GOTO   60D
0E09:  MOVLW  00
0E0A:  MOVWF  78
0E0B:  MOVWF  79
0E0C:  GOTO   75F
0E0D:  GOTO   55B
....................                 }
....................             } else {
0E0E:  GOTO   6C4
....................                 while (otop != -1 && op[otop] != '(' &&
....................                        uu_tien_toan_tu(op[otop]) >= uu_tien_toan_tu(c)) {
0E0F:  MOVF   69,W
0E10:  SUBLW  FF
0E11:  BTFSC  03.2
0E12:  GOTO   6C4
0E13:  MOVLW  C8
0E14:  ADDWF  69,W
0E15:  MOVWF  04
0E16:  BCF    03.7
0E17:  MOVF   00,W
0E18:  SUBLW  28
0E19:  BTFSC  03.2
0E1A:  GOTO   6C4
0E1B:  MOVLW  C8
0E1C:  ADDWF  69,W
0E1D:  MOVWF  04
0E1E:  BCF    03.7
0E1F:  MOVF   00,W
0E20:  BSF    03.6
0E21:  MOVWF  10
0E22:  MOVWF  25
0E23:  BCF    0A.3
0E24:  BCF    03.6
0E25:  CALL   2DA
0E26:  BSF    0A.3
0E27:  MOVF   79,W
0E28:  BSF    03.6
0E29:  MOVWF  11
0E2A:  MOVF   78,W
0E2B:  MOVWF  10
0E2C:  BCF    03.6
0E2D:  MOVF   6C,W
0E2E:  BSF    03.6
0E2F:  MOVWF  25
0E30:  BCF    0A.3
0E31:  BCF    03.6
0E32:  CALL   2DA
0E33:  BSF    0A.3
0E34:  MOVF   79,W
0E35:  MOVWF  7A
0E36:  MOVF   78,W
0E37:  BTFSS  7A.7
0E38:  GOTO   63E
0E39:  BSF    03.6
0E3A:  BTFSS  11.7
0E3B:  GOTO   651
0E3C:  GOTO   643
0E3D:  BCF    03.6
0E3E:  BSF    03.6
0E3F:  BTFSS  11.7
0E40:  GOTO   643
0E41:  BCF    03.6
0E42:  GOTO   6C4
0E43:  MOVF   7A,W
0E44:  SUBWF  11,W
0E45:  BTFSC  03.0
0E46:  GOTO   649
0E47:  BCF    03.6
0E48:  GOTO   6C4
0E49:  BTFSS  03.2
0E4A:  GOTO   651
0E4B:  MOVF   78,W
0E4C:  SUBWF  10,W
0E4D:  BTFSC  03.0
0E4E:  GOTO   651
0E4F:  BCF    03.6
0E50:  GOTO   6C4
....................                     if (vtop < 1) { loi = 1; return 0; }
0E51:  BCF    03.6
0E52:  MOVF   68,F
0E53:  BTFSS  03.2
0E54:  GOTO   65C
0E55:  CLRF   31
0E56:  MOVLW  01
0E57:  MOVWF  30
0E58:  MOVLW  00
0E59:  MOVWF  78
0E5A:  MOVWF  79
0E5B:  GOTO   75F
....................                     signed long b = val[vtop--];
....................                     signed long a = val[vtop--];
0E5C:  MOVF   68,W
0E5D:  DECF   68,F
0E5E:  MOVWF  77
0E5F:  BCF    03.0
0E60:  RLF    77,F
0E61:  MOVF   77,W
0E62:  ADDLW  A0
0E63:  MOVWF  04
0E64:  BCF    03.7
0E65:  INCF   04,F
0E66:  MOVF   00,W
0E67:  BSF    03.5
0E68:  MOVWF  69
0E69:  DECF   04,F
0E6A:  MOVF   00,W
0E6B:  MOVWF  68
0E6C:  BCF    03.5
0E6D:  MOVF   68,W
0E6E:  DECF   68,F
0E6F:  MOVWF  77
0E70:  BCF    03.0
0E71:  RLF    77,F
0E72:  MOVF   77,W
0E73:  ADDLW  A0
0E74:  MOVWF  04
0E75:  BCF    03.7
0E76:  INCF   04,F
0E77:  MOVF   00,W
0E78:  BSF    03.5
0E79:  MOVWF  6B
0E7A:  DECF   04,F
0E7B:  MOVF   00,W
0E7C:  MOVWF  6A
....................                     val[++vtop] = tinh_toan(a, b, op[otop--]);
0E7D:  BCF    03.5
0E7E:  INCF   68,F
0E7F:  BCF    03.0
0E80:  RLF    68,W
0E81:  ADDLW  A0
0E82:  BSF    03.6
0E83:  MOVWF  10
0E84:  CLRF   11
0E85:  BTFSC  03.0
0E86:  INCF   11,F
0E87:  BCF    03.6
0E88:  MOVF   69,W
0E89:  DECF   69,F
0E8A:  ADDLW  C8
0E8B:  MOVWF  04
0E8C:  BCF    03.7
0E8D:  MOVF   00,W
0E8E:  BSF    03.6
0E8F:  MOVWF  12
0E90:  BSF    03.5
0E91:  BCF    03.6
0E92:  MOVF   6B,W
0E93:  BCF    03.5
0E94:  BSF    03.6
0E95:  MOVWF  27
0E96:  BSF    03.5
0E97:  BCF    03.6
0E98:  MOVF   6A,W
0E99:  BCF    03.5
0E9A:  BSF    03.6
0E9B:  MOVWF  26
0E9C:  BSF    03.5
0E9D:  BCF    03.6
0E9E:  MOVF   69,W
0E9F:  BCF    03.5
0EA0:  BSF    03.6
0EA1:  MOVWF  29
0EA2:  BSF    03.5
0EA3:  BCF    03.6
0EA4:  MOVF   68,W
0EA5:  BCF    03.5
0EA6:  BSF    03.6
0EA7:  MOVWF  28
0EA8:  MOVF   12,W
0EA9:  MOVWF  2A
0EAA:  BCF    0A.3
0EAB:  BCF    03.6
0EAC:  CALL   367
0EAD:  BSF    0A.3
0EAE:  BSF    03.6
0EAF:  MOVF   10,W
0EB0:  MOVWF  04
0EB1:  BCF    03.7
0EB2:  BTFSC  11.0
0EB3:  BSF    03.7
0EB4:  INCF   04,F
0EB5:  MOVF   79,W
0EB6:  MOVWF  00
0EB7:  DECF   04,F
0EB8:  MOVF   78,W
0EB9:  MOVWF  00
....................                     if (loi) return 0;
0EBA:  BCF    03.6
0EBB:  MOVF   30,W
0EBC:  IORWF  31,W
0EBD:  BTFSC  03.2
0EBE:  GOTO   6C3
0EBF:  MOVLW  00
0EC0:  MOVWF  78
0EC1:  MOVWF  79
0EC2:  GOTO   75F
0EC3:  GOTO   60F
....................                 }
....................             }
....................             op[++otop] = c;
0EC4:  INCF   69,F
0EC5:  MOVLW  C8
0EC6:  ADDWF  69,W
0EC7:  MOVWF  04
0EC8:  BCF    03.7
0EC9:  MOVF   6C,W
0ECA:  MOVWF  00
....................         }
0ECB:  GOTO   6D3
....................         else {
....................             loi = 1;
0ECC:  CLRF   31
0ECD:  MOVLW  01
0ECE:  MOVWF  30
....................             return 0;
0ECF:  MOVLW  00
0ED0:  MOVWF  78
0ED1:  MOVWF  79
0ED2:  GOTO   75F
0ED3:  BSF    03.6
....................         }
0ED4:  BCF    03.6
0ED5:  INCF   6A,F
0ED6:  BTFSC  03.2
0ED7:  INCF   6B,F
0ED8:  GOTO   007
....................     }
.................... 
....................     while (otop != -1) {
0ED9:  MOVF   69,W
0EDA:  SUBLW  FF
0EDB:  BTFSC  03.2
0EDC:  GOTO   74F
....................         if (vtop < 1) { loi = 1; return 0; }
0EDD:  MOVF   68,F
0EDE:  BTFSS  03.2
0EDF:  GOTO   6E7
0EE0:  CLRF   31
0EE1:  MOVLW  01
0EE2:  MOVWF  30
0EE3:  MOVLW  00
0EE4:  MOVWF  78
0EE5:  MOVWF  79
0EE6:  GOTO   75F
....................         signed long b = val[vtop--];
....................         signed long a = val[vtop--];
0EE7:  MOVF   68,W
0EE8:  DECF   68,F
0EE9:  MOVWF  77
0EEA:  BCF    03.0
0EEB:  RLF    77,F
0EEC:  MOVF   77,W
0EED:  ADDLW  A0
0EEE:  MOVWF  04
0EEF:  BCF    03.7
0EF0:  INCF   04,F
0EF1:  MOVF   00,W
0EF2:  BSF    03.5
0EF3:  MOVWF  6D
0EF4:  DECF   04,F
0EF5:  MOVF   00,W
0EF6:  MOVWF  6C
0EF7:  BCF    03.5
0EF8:  MOVF   68,W
0EF9:  DECF   68,F
0EFA:  MOVWF  77
0EFB:  BCF    03.0
0EFC:  RLF    77,F
0EFD:  MOVF   77,W
0EFE:  ADDLW  A0
0EFF:  MOVWF  04
0F00:  BCF    03.7
0F01:  INCF   04,F
0F02:  MOVF   00,W
0F03:  BSF    03.5
0F04:  MOVWF  6F
0F05:  DECF   04,F
0F06:  MOVF   00,W
0F07:  MOVWF  6E
....................         val[++vtop] = tinh_toan(a, b, op[otop--]);
0F08:  BCF    03.5
0F09:  INCF   68,F
0F0A:  BCF    03.0
0F0B:  RLF    68,W
0F0C:  ADDLW  A0
0F0D:  BSF    03.6
0F0E:  MOVWF  10
0F0F:  CLRF   11
0F10:  BTFSC  03.0
0F11:  INCF   11,F
0F12:  BCF    03.6
0F13:  MOVF   69,W
0F14:  DECF   69,F
0F15:  ADDLW  C8
0F16:  MOVWF  04
0F17:  BCF    03.7
0F18:  MOVF   00,W
0F19:  BSF    03.6
0F1A:  MOVWF  12
0F1B:  BSF    03.5
0F1C:  BCF    03.6
0F1D:  MOVF   6F,W
0F1E:  BCF    03.5
0F1F:  BSF    03.6
0F20:  MOVWF  27
0F21:  BSF    03.5
0F22:  BCF    03.6
0F23:  MOVF   6E,W
0F24:  BCF    03.5
0F25:  BSF    03.6
0F26:  MOVWF  26
0F27:  BSF    03.5
0F28:  BCF    03.6
0F29:  MOVF   6D,W
0F2A:  BCF    03.5
0F2B:  BSF    03.6
0F2C:  MOVWF  29
0F2D:  BSF    03.5
0F2E:  BCF    03.6
0F2F:  MOVF   6C,W
0F30:  BCF    03.5
0F31:  BSF    03.6
0F32:  MOVWF  28
0F33:  MOVF   12,W
0F34:  MOVWF  2A
0F35:  BCF    0A.3
0F36:  BCF    03.6
0F37:  CALL   367
0F38:  BSF    0A.3
0F39:  BSF    03.6
0F3A:  MOVF   10,W
0F3B:  MOVWF  04
0F3C:  BCF    03.7
0F3D:  BTFSC  11.0
0F3E:  BSF    03.7
0F3F:  INCF   04,F
0F40:  MOVF   79,W
0F41:  MOVWF  00
0F42:  DECF   04,F
0F43:  MOVF   78,W
0F44:  MOVWF  00
....................         if (loi) return 0;
0F45:  BCF    03.6
0F46:  MOVF   30,W
0F47:  IORWF  31,W
0F48:  BTFSC  03.2
0F49:  GOTO   74E
0F4A:  MOVLW  00
0F4B:  MOVWF  78
0F4C:  MOVWF  79
0F4D:  GOTO   75F
0F4E:  GOTO   6D9
....................     }
.................... 
....................     if (vtop == 0) return val[0];
0F4F:  MOVF   68,F
0F50:  BTFSS  03.2
0F51:  GOTO   759
0F52:  BSF    03.5
0F53:  MOVF   20,W
0F54:  MOVWF  78
0F55:  MOVF   21,W
0F56:  MOVWF  79
0F57:  BCF    03.5
0F58:  GOTO   75F
....................     loi = 1;
0F59:  CLRF   31
0F5A:  MOVLW  01
0F5B:  MOVWF  30
....................     return 0;
0F5C:  MOVLW  00
0F5D:  MOVWF  78
0F5E:  MOVWF  79
0F5F:  RETURN
.................... }
.................... 
.................... int la_mu_chan(char *bt) {
*
05B5:  CLRF   68
....................     int i = 0;
....................     while (bt[i] && bt[i] != '^') i++;
05B6:  MOVF   68,W
05B7:  ADDWF  66,W
05B8:  MOVWF  04
05B9:  BCF    03.7
05BA:  BTFSC  67.0
05BB:  BSF    03.7
05BC:  MOVF   00,F
05BD:  BTFSC  03.2
05BE:  GOTO   5CB
05BF:  MOVF   68,W
05C0:  ADDWF  66,W
05C1:  MOVWF  04
05C2:  BCF    03.7
05C3:  BTFSC  67.0
05C4:  BSF    03.7
05C5:  MOVF   00,W
05C6:  SUBLW  5E
05C7:  BTFSC  03.2
05C8:  GOTO   5CB
05C9:  INCF   68,F
05CA:  GOTO   5B6
....................     if (bt[i] != '^') return 1; // không có m?
05CB:  MOVF   68,W
05CC:  ADDWF  66,W
05CD:  MOVWF  04
05CE:  BCF    03.7
05CF:  BTFSC  67.0
05D0:  BSF    03.7
05D1:  MOVF   00,W
05D2:  SUBLW  5E
05D3:  BTFSC  03.2
05D4:  GOTO   5D8
05D5:  MOVLW  01
05D6:  MOVWF  78
05D7:  GOTO   62A
....................     i++;
05D8:  INCF   68,F
....................     int mu = 0;
05D9:  CLRF   69
....................     while (bt[i] >= '0' && bt[i] <= '9') {
05DA:  MOVF   68,W
05DB:  ADDWF  66,W
05DC:  MOVWF  04
05DD:  BCF    03.7
05DE:  BTFSC  67.0
05DF:  BSF    03.7
05E0:  MOVF   00,W
05E1:  SUBLW  2F
05E2:  BTFSC  03.0
05E3:  GOTO   622
05E4:  MOVF   68,W
05E5:  ADDWF  66,W
05E6:  MOVWF  04
05E7:  BCF    03.7
05E8:  BTFSC  67.0
05E9:  BSF    03.7
05EA:  MOVF   00,W
05EB:  SUBLW  39
05EC:  BTFSS  03.0
05ED:  GOTO   622
....................         mu = mu * 10 + (bt[i] - '0');
05EE:  MOVF   69,W
05EF:  MOVWF  6A
05F0:  MOVLW  0A
05F1:  MOVWF  6B
*
0616:  MOVF   68,W
0617:  ADDWF  66,W
0618:  MOVWF  04
0619:  BCF    03.7
061A:  BTFSC  67.0
061B:  BSF    03.7
061C:  MOVLW  30
061D:  SUBWF  00,W
061E:  ADDWF  78,W
061F:  MOVWF  69
....................         i++;
0620:  INCF   68,F
0621:  GOTO   5DA
....................     }
....................     return (mu % 2 == 0);
0622:  MOVF   69,W
0623:  ANDLW  01
0624:  BTFSC  03.2
0625:  GOTO   628
0626:  MOVLW  00
0627:  GOTO   629
0628:  MOVLW  01
0629:  MOVWF  78
062A:  BCF    0A.3
062B:  BSF    0A.4
062C:  GOTO   719 (RETURN)
.................... }
.................... 
.................... 
.................... // ================== MAIN ==================
.................... void main() {
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  20
1005:  MOVLW  08
1006:  MOVWF  29
1007:  CLRF   2B
1008:  CLRF   2A
1009:  CLRF   2D
100A:  CLRF   2C
100B:  CLRF   2F
100C:  CLRF   2E
100D:  CLRF   31
100E:  CLRF   30
100F:  BCF    27.1
1010:  CLRF   33
1011:  CLRF   32
1012:  BSF    03.5
1013:  BSF    03.6
1014:  MOVF   09,W
1015:  ANDLW  C0
1016:  MOVWF  09
1017:  BCF    03.6
1018:  BCF    1F.4
1019:  BCF    1F.5
101A:  MOVLW  00
101B:  BSF    03.6
101C:  MOVWF  08
101D:  BCF    03.5
101E:  CLRF   07
101F:  CLRF   08
1020:  CLRF   09
1021:  BCF    03.7
....................     delay_ms(500);
*
1025:  MOVLW  02
1026:  MOVWF  66
1027:  MOVLW  FA
1028:  MOVWF  67
1029:  BCF    0A.4
102A:  CALL   02C
102B:  BSF    0A.4
102C:  DECFSZ 66,F
102D:  GOTO   027
....................     setup_adc_ports(NO_ANALOGS);
102E:  BSF    03.5
102F:  BSF    03.6
1030:  MOVF   09,W
1031:  ANDLW  C0
1032:  MOVWF  09
1033:  BCF    03.6
1034:  BCF    1F.4
1035:  BCF    1F.5
1036:  MOVLW  00
1037:  BSF    03.6
1038:  MOVWF  08
....................     setup_adc(ADC_OFF);
1039:  BCF    03.5
103A:  BCF    03.6
103B:  BCF    1F.0
....................     char phim;
....................     char bieu_thuc[15];
....................     int8 vi_tri = 0;
....................     int1 da_xong = 0;
....................     int1 man_hinh_ban_dau = 1;
....................     char buf[12];
103C:  CLRF   44
103D:  BCF    45.0
103E:  BSF    45.1
.................... 
....................     set_tris_a(0xFF);
103F:  MOVLW  FF
1040:  BSF    03.5
1041:  MOVWF  05
....................     set_tris_b(0xF0);
1042:  MOVLW  F0
1043:  MOVWF  06
....................     set_tris_c(0xFF);
1044:  MOVLW  FF
1045:  MOVWF  07
1046:  BCF    03.5
1047:  MOVWF  20
....................   
....................     set_tris_e(0xFF);
1048:  BSF    03.5
1049:  BSF    09.0
104A:  BSF    09.1
104B:  BSF    09.2
104C:  BSF    09.3
....................     port_b_pullups(TRUE);
104D:  MOVLW  01
104E:  MOVWF  15
104F:  BCF    01.7
.................... 
....................     LCD_Begin(LCD_ADDR);
1050:  MOVLW  4E
1051:  BCF    03.5
1052:  MOVWF  66
1053:  BCF    0A.4
1054:  GOTO   10C
1055:  BSF    0A.4
....................     LCD_Cmd(LCD_CLEAR);
1056:  MOVLW  01
1057:  MOVWF  6A
1058:  BCF    0A.4
1059:  CALL   0FC
105A:  BSF    0A.4
.................... 
....................     // màn h?nh ban ð?u
....................     LCD_Goto(1,1);
105B:  MOVLW  01
105C:  MOVWF  67
105D:  MOVWF  68
105E:  BCF    0A.4
105F:  CALL   146
1060:  BSF    0A.4
....................    LCD_Out('X'); LCD_Out('I'); LCD_Out('N'); LCD_Out(' ');
1061:  MOVLW  58
1062:  MOVWF  67
1063:  BCF    0A.4
1064:  CALL   16D
1065:  BSF    0A.4
1066:  MOVLW  49
1067:  MOVWF  67
1068:  BCF    0A.4
1069:  CALL   16D
106A:  BSF    0A.4
106B:  MOVLW  4E
106C:  MOVWF  67
106D:  BCF    0A.4
106E:  CALL   16D
106F:  BSF    0A.4
1070:  MOVLW  20
1071:  MOVWF  67
1072:  BCF    0A.4
1073:  CALL   16D
1074:  BSF    0A.4
....................    LCD_Out('C'); LCD_Out('H'); LCD_Out('A'); LCD_Out('O');
1075:  MOVLW  43
1076:  MOVWF  67
1077:  BCF    0A.4
1078:  CALL   16D
1079:  BSF    0A.4
107A:  MOVLW  48
107B:  MOVWF  67
107C:  BCF    0A.4
107D:  CALL   16D
107E:  BSF    0A.4
107F:  MOVLW  41
1080:  MOVWF  67
1081:  BCF    0A.4
1082:  CALL   16D
1083:  BSF    0A.4
1084:  MOVLW  4F
1085:  MOVWF  67
1086:  BCF    0A.4
1087:  CALL   16D
1088:  BSF    0A.4
....................    LCD_Goto(1,2);
1089:  MOVLW  01
108A:  MOVWF  67
108B:  MOVLW  02
108C:  MOVWF  68
108D:  BCF    0A.4
108E:  CALL   146
108F:  BSF    0A.4
....................     bieu_thuc[0] = '\0';
1090:  CLRF   35
....................     while(doc_phim() != 0);
1091:  BCF    0A.4
1092:  CALL   17D
1093:  BSF    0A.4
1094:  MOVF   78,F
1095:  BTFSS  03.2
1096:  GOTO   091
.................... 
....................     while(TRUE) {
....................         phim = doc_phim();
1097:  BCF    0A.4
1098:  CALL   17D
1099:  BSF    0A.4
109A:  MOVF   78,W
109B:  MOVWF  34
....................         if(phim) {
109C:  MOVF   34,F
109D:  BTFSC  03.2
109E:  GOTO   7F8
....................             while(doc_phim() == phim);
109F:  BCF    0A.4
10A0:  CALL   17D
10A1:  BSF    0A.4
10A2:  MOVF   34,W
10A3:  SUBWF  78,W
10A4:  BTFSC  03.2
10A5:  GOTO   09F
....................             delay_ms(200);
10A6:  MOVLW  C8
10A7:  MOVWF  67
10A8:  BCF    0A.4
10A9:  CALL   02C
10AA:  BSF    0A.4
....................             if(phim == 'S') {
10AB:  MOVF   34,W
10AC:  SUBLW  53
10AD:  BTFSS  03.2
10AE:  GOTO   0D1
.................... 
....................     // >>> THÊM ÐO?N NÀY <<<
....................     if(man_hinh_ban_dau) {
10AF:  BTFSS  45.1
10B0:  GOTO   0C4
....................         LCD_Goto(1,1); for(int i=0;i<8;i++) LCD_Out(' ');
10B1:  MOVLW  01
10B2:  MOVWF  67
10B3:  MOVWF  68
10B4:  BCF    0A.4
10B5:  CALL   146
10B6:  BSF    0A.4
10B7:  CLRF   52
10B8:  MOVF   52,W
10B9:  SUBLW  07
10BA:  BTFSS  03.0
10BB:  GOTO   0C3
10BC:  MOVLW  20
10BD:  MOVWF  67
10BE:  BCF    0A.4
10BF:  CALL   16D
10C0:  BSF    0A.4
10C1:  INCF   52,F
10C2:  GOTO   0B8
....................         man_hinh_ban_dau = 0;
10C3:  BCF    45.1
....................     }
.................... 
....................     shift_mode = !shift_mode;
10C4:  MOVLW  02
10C5:  XORWF  27,F
....................     cap_nhat_shift_lcd();
10C6:  BCF    0A.4
10C7:  CALL   219
10C8:  BSF    0A.4
.................... 
....................     while(doc_phim() == 'S');
10C9:  BCF    0A.4
10CA:  CALL   17D
10CB:  BSF    0A.4
10CC:  MOVF   78,W
10CD:  SUBLW  53
10CE:  BTFSC  03.2
10CF:  GOTO   0C9
....................     continue;
10D0:  GOTO   097
.................... }
.................... 
.................... 
.................... // ===== T?T SHIFT SAU 1 PHÍM =====
.................... if(shift_mode) {
10D1:  BTFSS  27.1
10D2:  GOTO   0D7
....................     shift_mode = 0;
10D3:  BCF    27.1
....................     cap_nhat_shift_lcd();
10D4:  BCF    0A.4
10D5:  CALL   219
10D6:  BSF    0A.4
.................... }
....................             // xóa màn h?nh ban ð?u khi b?m phím ð?u tiên
....................             if(man_hinh_ban_dau && phim != 'C') {
10D7:  BTFSS  45.1
10D8:  GOTO   103
10D9:  MOVF   34,W
10DA:  SUBLW  43
10DB:  BTFSC  03.2
10DC:  GOTO   103
....................                 LCD_Goto(1,1); for(int i=0;i<16;i++) LCD_Out(' ');
10DD:  MOVLW  01
10DE:  MOVWF  67
10DF:  MOVWF  68
10E0:  BCF    0A.4
10E1:  CALL   146
10E2:  BSF    0A.4
10E3:  CLRF   53
10E4:  MOVF   53,W
10E5:  SUBLW  0F
10E6:  BTFSS  03.0
10E7:  GOTO   0EF
10E8:  MOVLW  20
10E9:  MOVWF  67
10EA:  BCF    0A.4
10EB:  CALL   16D
10EC:  BSF    0A.4
10ED:  INCF   53,F
10EE:  GOTO   0E4
....................                 LCD_Goto(1,2); for(int i=0;i<16;i++) LCD_Out(' ');
10EF:  MOVLW  01
10F0:  MOVWF  67
10F1:  MOVLW  02
10F2:  MOVWF  68
10F3:  BCF    0A.4
10F4:  CALL   146
10F5:  BSF    0A.4
10F6:  CLRF   54
10F7:  MOVF   54,W
10F8:  SUBLW  0F
10F9:  BTFSS  03.0
10FA:  GOTO   102
10FB:  MOVLW  20
10FC:  MOVWF  67
10FD:  BCF    0A.4
10FE:  CALL   16D
10FF:  BSF    0A.4
1100:  INCF   54,F
1101:  GOTO   0F7
....................                 man_hinh_ban_dau = 0;
1102:  BCF    45.1
....................             }
....................             // CLEAR
....................            if(phim == 'C') {
1103:  MOVF   34,W
1104:  SUBLW  43
1105:  BTFSS  03.2
1106:  GOTO   146
....................        shift_mode = 0;
1107:  BCF    27.1
....................        cap_nhat_shift_lcd();
1108:  BCF    0A.4
1109:  CALL   219
110A:  BSF    0A.4
....................    
....................        LCD_Cmd(LCD_CLEAR);
110B:  MOVLW  01
110C:  MOVWF  6A
110D:  BCF    0A.4
110E:  CALL   0FC
110F:  BSF    0A.4
....................        cap_nhat_shift_lcd();
1110:  BCF    0A.4
1111:  CALL   219
1112:  BSF    0A.4
....................    
....................        LCD_Goto(1,1);
1113:  MOVLW  01
1114:  MOVWF  67
1115:  MOVWF  68
1116:  BCF    0A.4
1117:  CALL   146
1118:  BSF    0A.4
....................        LCD_Out('X'); LCD_Out('I'); LCD_Out('N'); LCD_Out(' ');
1119:  MOVLW  58
111A:  MOVWF  67
111B:  BCF    0A.4
111C:  CALL   16D
111D:  BSF    0A.4
111E:  MOVLW  49
111F:  MOVWF  67
1120:  BCF    0A.4
1121:  CALL   16D
1122:  BSF    0A.4
1123:  MOVLW  4E
1124:  MOVWF  67
1125:  BCF    0A.4
1126:  CALL   16D
1127:  BSF    0A.4
1128:  MOVLW  20
1129:  MOVWF  67
112A:  BCF    0A.4
112B:  CALL   16D
112C:  BSF    0A.4
....................        LCD_Out('C'); LCD_Out('H'); LCD_Out('A'); LCD_Out('O');
112D:  MOVLW  43
112E:  MOVWF  67
112F:  BCF    0A.4
1130:  CALL   16D
1131:  BSF    0A.4
1132:  MOVLW  48
1133:  MOVWF  67
1134:  BCF    0A.4
1135:  CALL   16D
1136:  BSF    0A.4
1137:  MOVLW  41
1138:  MOVWF  67
1139:  BCF    0A.4
113A:  CALL   16D
113B:  BSF    0A.4
113C:  MOVLW  4F
113D:  MOVWF  67
113E:  BCF    0A.4
113F:  CALL   16D
1140:  BSF    0A.4
....................    
....................        vi_tri = 0;
1141:  CLRF   44
....................        bieu_thuc[0] = '\0';
1142:  CLRF   35
....................        da_xong = 0;
1143:  BCF    45.0
....................        man_hinh_ban_dau = 1;
1144:  BSF    45.1
....................    }
1145:  GOTO   7F8
.................... 
....................             // BACKSPACE
....................             else if(phim == 'D') {
1146:  MOVF   34,W
1147:  SUBLW  44
1148:  BTFSS  03.2
1149:  GOTO   16B
....................                 if(vi_tri > 0) {
114A:  MOVF   44,F
114B:  BTFSC  03.2
114C:  GOTO   16A
....................                     vi_tri--;
114D:  DECF   44,F
....................                     bieu_thuc[vi_tri] = '\0';
114E:  MOVLW  35
114F:  ADDWF  44,W
1150:  MOVWF  04
1151:  BCF    03.7
1152:  CLRF   00
....................                     LCD_Goto(vi_tri + 1, 1);
1153:  MOVLW  01
1154:  ADDWF  44,W
1155:  MOVWF  66
1156:  MOVWF  67
1157:  MOVLW  01
1158:  MOVWF  68
1159:  BCF    0A.4
115A:  CALL   146
115B:  BSF    0A.4
....................                     LCD_Out(' ');
115C:  MOVLW  20
115D:  MOVWF  67
115E:  BCF    0A.4
115F:  CALL   16D
1160:  BSF    0A.4
....................                     LCD_Goto(vi_tri + 1, 1);
1161:  MOVLW  01
1162:  ADDWF  44,W
1163:  MOVWF  66
1164:  MOVWF  67
1165:  MOVLW  01
1166:  MOVWF  68
1167:  BCF    0A.4
1168:  CALL   146
1169:  BSF    0A.4
....................                 }
....................             }
116A:  GOTO   7F8
.................... 
....................             // I
....................            else if(phim == 'I') {
116B:  MOVF   34,W
116C:  SUBLW  49
116D:  BTFSS  03.2
116E:  GOTO   23A
....................     if(da_xong) {
116F:  BTFSS  45.0
1170:  GOTO   213
....................         // KI?M TRA L?I TRÝ?C KHI LÝU
....................         if(loi != 0) {
1171:  MOVF   30,F
1172:  BTFSS  03.2
1173:  GOTO   177
1174:  MOVF   31,F
1175:  BTFSC  03.2
1176:  GOTO   1D9
....................             // Hi?n th? ERR
....................             LCD_Cmd(LCD_CLEAR);
1177:  MOVLW  01
1178:  MOVWF  6A
1179:  BCF    0A.4
117A:  CALL   0FC
117B:  BSF    0A.4
....................             LCD_Goto(1,1);
117C:  MOVLW  01
117D:  MOVWF  67
117E:  MOVWF  68
117F:  BCF    0A.4
1180:  CALL   146
1181:  BSF    0A.4
....................             LCD_Out('E'); LCD_Out('R'); LCD_Out('R');
1182:  MOVLW  45
1183:  MOVWF  67
1184:  BCF    0A.4
1185:  CALL   16D
1186:  BSF    0A.4
1187:  MOVLW  52
1188:  MOVWF  67
1189:  BCF    0A.4
118A:  CALL   16D
118B:  BSF    0A.4
118C:  MOVLW  52
118D:  MOVWF  67
118E:  BCF    0A.4
118F:  CALL   16D
1190:  BSF    0A.4
....................             delay_ms(1000);
1191:  MOVLW  04
1192:  MOVWF  66
1193:  MOVLW  FA
1194:  MOVWF  67
1195:  BCF    0A.4
1196:  CALL   02C
1197:  BSF    0A.4
1198:  DECFSZ 66,F
1199:  GOTO   193
....................             
....................             // Kích ho?t phím C (Clear)
....................             shift_mode = 0;
119A:  BCF    27.1
....................             cap_nhat_shift_lcd();
119B:  BCF    0A.4
119C:  CALL   219
119D:  BSF    0A.4
....................             
....................             LCD_Cmd(LCD_CLEAR);
119E:  MOVLW  01
119F:  MOVWF  6A
11A0:  BCF    0A.4
11A1:  CALL   0FC
11A2:  BSF    0A.4
....................             cap_nhat_shift_lcd();
11A3:  BCF    0A.4
11A4:  CALL   219
11A5:  BSF    0A.4
....................             
....................             LCD_Goto(1,1);
11A6:  MOVLW  01
11A7:  MOVWF  67
11A8:  MOVWF  68
11A9:  BCF    0A.4
11AA:  CALL   146
11AB:  BSF    0A.4
....................             LCD_Out('X'); LCD_Out('I'); LCD_Out('N'); LCD_Out(' ');
11AC:  MOVLW  58
11AD:  MOVWF  67
11AE:  BCF    0A.4
11AF:  CALL   16D
11B0:  BSF    0A.4
11B1:  MOVLW  49
11B2:  MOVWF  67
11B3:  BCF    0A.4
11B4:  CALL   16D
11B5:  BSF    0A.4
11B6:  MOVLW  4E
11B7:  MOVWF  67
11B8:  BCF    0A.4
11B9:  CALL   16D
11BA:  BSF    0A.4
11BB:  MOVLW  20
11BC:  MOVWF  67
11BD:  BCF    0A.4
11BE:  CALL   16D
11BF:  BSF    0A.4
....................             LCD_Out('C'); LCD_Out('H'); LCD_Out('A'); LCD_Out('O');
11C0:  MOVLW  43
11C1:  MOVWF  67
11C2:  BCF    0A.4
11C3:  CALL   16D
11C4:  BSF    0A.4
11C5:  MOVLW  48
11C6:  MOVWF  67
11C7:  BCF    0A.4
11C8:  CALL   16D
11C9:  BSF    0A.4
11CA:  MOVLW  41
11CB:  MOVWF  67
11CC:  BCF    0A.4
11CD:  CALL   16D
11CE:  BSF    0A.4
11CF:  MOVLW  4F
11D0:  MOVWF  67
11D1:  BCF    0A.4
11D2:  CALL   16D
11D3:  BSF    0A.4
....................             
....................             vi_tri = 0;
11D4:  CLRF   44
....................             bieu_thuc[0] = '\0';
11D5:  CLRF   35
....................             da_xong = 0;
11D6:  BCF    45.0
....................             man_hinh_ban_dau = 1;
11D7:  BSF    45.1
....................         } else {
11D8:  GOTO   212
....................             luu_gia_tri_I = ANS;
11D9:  MOVF   2B,W
11DA:  MOVWF  2D
11DB:  MOVF   2A,W
11DC:  MOVWF  2C
....................             LCD_Cmd(LCD_CLEAR);
11DD:  MOVLW  01
11DE:  MOVWF  6A
11DF:  BCF    0A.4
11E0:  CALL   0FC
11E1:  BSF    0A.4
....................             LCD_Goto(1,1);
11E2:  MOVLW  01
11E3:  MOVWF  67
11E4:  MOVWF  68
11E5:  BCF    0A.4
11E6:  CALL   146
11E7:  BSF    0A.4
....................             LCD_Out('L'); LCD_Out('U'); LCD_Out('U'); LCD_Out(' ');
11E8:  MOVLW  4C
11E9:  MOVWF  67
11EA:  BCF    0A.4
11EB:  CALL   16D
11EC:  BSF    0A.4
11ED:  MOVLW  55
11EE:  MOVWF  67
11EF:  BCF    0A.4
11F0:  CALL   16D
11F1:  BSF    0A.4
11F2:  MOVLW  55
11F3:  MOVWF  67
11F4:  BCF    0A.4
11F5:  CALL   16D
11F6:  BSF    0A.4
11F7:  MOVLW  20
11F8:  MOVWF  67
11F9:  BCF    0A.4
11FA:  CALL   16D
11FB:  BSF    0A.4
....................             LCD_Out('I');
11FC:  MOVLW  49
11FD:  MOVWF  67
11FE:  BCF    0A.4
11FF:  CALL   16D
1200:  BSF    0A.4
....................             delay_ms(1000);
1201:  MOVLW  04
1202:  MOVWF  66
1203:  MOVLW  FA
1204:  MOVWF  67
1205:  BCF    0A.4
1206:  CALL   02C
1207:  BSF    0A.4
1208:  DECFSZ 66,F
1209:  GOTO   203
....................             LCD_Cmd(LCD_CLEAR);
120A:  MOVLW  01
120B:  MOVWF  6A
120C:  BCF    0A.4
120D:  CALL   0FC
120E:  BSF    0A.4
....................             man_hinh_ban_dau = 1;
120F:  BSF    45.1
....................             vi_tri = 0;
1210:  CLRF   44
....................             da_xong = 0;
1211:  BCF    45.0
....................         }
....................     } else {
1212:  GOTO   239
....................         if(da_xong) {
1213:  BTFSS  45.0
1214:  GOTO   21D
....................             LCD_Cmd(LCD_CLEAR);
1215:  MOVLW  01
1216:  MOVWF  6A
1217:  BCF    0A.4
1218:  CALL   0FC
1219:  BSF    0A.4
....................             vi_tri = 0;
121A:  CLRF   44
....................             bieu_thuc[0] = '\0';
121B:  CLRF   35
....................             da_xong = 0;
121C:  BCF    45.0
....................         }
....................         if(vi_tri < 14) {
121D:  MOVF   44,W
121E:  SUBLW  0D
121F:  BTFSS  03.0
1220:  GOTO   239
....................             bieu_thuc[vi_tri++] = 'I';
1221:  MOVF   44,W
1222:  INCF   44,F
1223:  ADDLW  35
1224:  MOVWF  04
1225:  BCF    03.7
1226:  MOVLW  49
1227:  MOVWF  00
....................             bieu_thuc[vi_tri] = '\0';
1228:  MOVLW  35
1229:  ADDWF  44,W
122A:  MOVWF  04
122B:  BCF    03.7
122C:  CLRF   00
....................             LCD_Goto(vi_tri,1);
122D:  MOVF   44,W
122E:  MOVWF  67
122F:  MOVLW  01
1230:  MOVWF  68
1231:  BCF    0A.4
1232:  CALL   146
1233:  BSF    0A.4
....................             LCD_Out('I');
1234:  MOVLW  49
1235:  MOVWF  67
1236:  BCF    0A.4
1237:  CALL   16D
1238:  BSF    0A.4
....................         }
....................     }
.................... }
1239:  GOTO   7F8
.................... 
....................             // J
.................... else if(phim == 'J') {
123A:  MOVF   34,W
123B:  SUBLW  4A
123C:  BTFSS  03.2
123D:  GOTO   309
....................     if(da_xong) {
123E:  BTFSS  45.0
123F:  GOTO   2E2
....................         // KI?M TRA L?I TRÝ?C KHI LÝU
....................         if(loi != 0) {
1240:  MOVF   30,F
1241:  BTFSS  03.2
1242:  GOTO   246
1243:  MOVF   31,F
1244:  BTFSC  03.2
1245:  GOTO   2A8
....................             // Hi?n th? ERR
....................             LCD_Cmd(LCD_CLEAR);
1246:  MOVLW  01
1247:  MOVWF  6A
1248:  BCF    0A.4
1249:  CALL   0FC
124A:  BSF    0A.4
....................             LCD_Goto(1,1);
124B:  MOVLW  01
124C:  MOVWF  67
124D:  MOVWF  68
124E:  BCF    0A.4
124F:  CALL   146
1250:  BSF    0A.4
....................             LCD_Out('E'); LCD_Out('R'); LCD_Out('R');
1251:  MOVLW  45
1252:  MOVWF  67
1253:  BCF    0A.4
1254:  CALL   16D
1255:  BSF    0A.4
1256:  MOVLW  52
1257:  MOVWF  67
1258:  BCF    0A.4
1259:  CALL   16D
125A:  BSF    0A.4
125B:  MOVLW  52
125C:  MOVWF  67
125D:  BCF    0A.4
125E:  CALL   16D
125F:  BSF    0A.4
....................             delay_ms(1000);
1260:  MOVLW  04
1261:  MOVWF  66
1262:  MOVLW  FA
1263:  MOVWF  67
1264:  BCF    0A.4
1265:  CALL   02C
1266:  BSF    0A.4
1267:  DECFSZ 66,F
1268:  GOTO   262
....................             
....................             // Kích ho?t phím C (Clear)
....................             shift_mode = 0;
1269:  BCF    27.1
....................             cap_nhat_shift_lcd();
126A:  BCF    0A.4
126B:  CALL   219
126C:  BSF    0A.4
....................             
....................             LCD_Cmd(LCD_CLEAR);
126D:  MOVLW  01
126E:  MOVWF  6A
126F:  BCF    0A.4
1270:  CALL   0FC
1271:  BSF    0A.4
....................             cap_nhat_shift_lcd();
1272:  BCF    0A.4
1273:  CALL   219
1274:  BSF    0A.4
....................             
....................             LCD_Goto(1,1);
1275:  MOVLW  01
1276:  MOVWF  67
1277:  MOVWF  68
1278:  BCF    0A.4
1279:  CALL   146
127A:  BSF    0A.4
....................             LCD_Out('X'); LCD_Out('I'); LCD_Out('N'); LCD_Out(' ');
127B:  MOVLW  58
127C:  MOVWF  67
127D:  BCF    0A.4
127E:  CALL   16D
127F:  BSF    0A.4
1280:  MOVLW  49
1281:  MOVWF  67
1282:  BCF    0A.4
1283:  CALL   16D
1284:  BSF    0A.4
1285:  MOVLW  4E
1286:  MOVWF  67
1287:  BCF    0A.4
1288:  CALL   16D
1289:  BSF    0A.4
128A:  MOVLW  20
128B:  MOVWF  67
128C:  BCF    0A.4
128D:  CALL   16D
128E:  BSF    0A.4
....................             LCD_Out('C'); LCD_Out('H'); LCD_Out('A'); LCD_Out('O');
128F:  MOVLW  43
1290:  MOVWF  67
1291:  BCF    0A.4
1292:  CALL   16D
1293:  BSF    0A.4
1294:  MOVLW  48
1295:  MOVWF  67
1296:  BCF    0A.4
1297:  CALL   16D
1298:  BSF    0A.4
1299:  MOVLW  41
129A:  MOVWF  67
129B:  BCF    0A.4
129C:  CALL   16D
129D:  BSF    0A.4
129E:  MOVLW  4F
129F:  MOVWF  67
12A0:  BCF    0A.4
12A1:  CALL   16D
12A2:  BSF    0A.4
....................             
....................             vi_tri = 0;
12A3:  CLRF   44
....................             bieu_thuc[0] = '\0';
12A4:  CLRF   35
....................             da_xong = 0;
12A5:  BCF    45.0
....................             man_hinh_ban_dau = 1;
12A6:  BSF    45.1
....................         } else {
12A7:  GOTO   2E1
....................             luu_gia_tri_J = ANS;
12A8:  MOVF   2B,W
12A9:  MOVWF  2F
12AA:  MOVF   2A,W
12AB:  MOVWF  2E
....................             LCD_Cmd(LCD_CLEAR);
12AC:  MOVLW  01
12AD:  MOVWF  6A
12AE:  BCF    0A.4
12AF:  CALL   0FC
12B0:  BSF    0A.4
....................             LCD_Goto(1,1);
12B1:  MOVLW  01
12B2:  MOVWF  67
12B3:  MOVWF  68
12B4:  BCF    0A.4
12B5:  CALL   146
12B6:  BSF    0A.4
....................             LCD_Out('L'); LCD_Out('U'); LCD_Out('U'); LCD_Out(' ');
12B7:  MOVLW  4C
12B8:  MOVWF  67
12B9:  BCF    0A.4
12BA:  CALL   16D
12BB:  BSF    0A.4
12BC:  MOVLW  55
12BD:  MOVWF  67
12BE:  BCF    0A.4
12BF:  CALL   16D
12C0:  BSF    0A.4
12C1:  MOVLW  55
12C2:  MOVWF  67
12C3:  BCF    0A.4
12C4:  CALL   16D
12C5:  BSF    0A.4
12C6:  MOVLW  20
12C7:  MOVWF  67
12C8:  BCF    0A.4
12C9:  CALL   16D
12CA:  BSF    0A.4
....................             LCD_Out('J');
12CB:  MOVLW  4A
12CC:  MOVWF  67
12CD:  BCF    0A.4
12CE:  CALL   16D
12CF:  BSF    0A.4
....................             delay_ms(1000);
12D0:  MOVLW  04
12D1:  MOVWF  66
12D2:  MOVLW  FA
12D3:  MOVWF  67
12D4:  BCF    0A.4
12D5:  CALL   02C
12D6:  BSF    0A.4
12D7:  DECFSZ 66,F
12D8:  GOTO   2D2
....................             LCD_Cmd(LCD_CLEAR);
12D9:  MOVLW  01
12DA:  MOVWF  6A
12DB:  BCF    0A.4
12DC:  CALL   0FC
12DD:  BSF    0A.4
....................             man_hinh_ban_dau = 1;
12DE:  BSF    45.1
....................             vi_tri = 0;
12DF:  CLRF   44
....................             da_xong = 0;
12E0:  BCF    45.0
....................         }
....................     } else {
12E1:  GOTO   308
....................         if(da_xong) {
12E2:  BTFSS  45.0
12E3:  GOTO   2EC
....................             LCD_Cmd(LCD_CLEAR);
12E4:  MOVLW  01
12E5:  MOVWF  6A
12E6:  BCF    0A.4
12E7:  CALL   0FC
12E8:  BSF    0A.4
....................             vi_tri = 0;
12E9:  CLRF   44
....................             bieu_thuc[0] = '\0';
12EA:  CLRF   35
....................             da_xong = 0;
12EB:  BCF    45.0
....................         }
....................         if(vi_tri < 14) {
12EC:  MOVF   44,W
12ED:  SUBLW  0D
12EE:  BTFSS  03.0
12EF:  GOTO   308
....................             bieu_thuc[vi_tri++] = 'J';
12F0:  MOVF   44,W
12F1:  INCF   44,F
12F2:  ADDLW  35
12F3:  MOVWF  04
12F4:  BCF    03.7
12F5:  MOVLW  4A
12F6:  MOVWF  00
....................             bieu_thuc[vi_tri] = '\0';
12F7:  MOVLW  35
12F8:  ADDWF  44,W
12F9:  MOVWF  04
12FA:  BCF    03.7
12FB:  CLRF   00
....................             LCD_Goto(vi_tri,1);
12FC:  MOVF   44,W
12FD:  MOVWF  67
12FE:  MOVLW  01
12FF:  MOVWF  68
1300:  BCF    0A.4
1301:  CALL   146
1302:  BSF    0A.4
....................             LCD_Out('J');
1303:  MOVLW  4A
1304:  MOVWF  67
1305:  BCF    0A.4
1306:  CALL   16D
1307:  BSF    0A.4
....................         }
....................     }
.................... }
1308:  GOTO   7F8
.................... 
.................... 
.................... // V (View All - Xem t?t c? bi?n)
.................... else if(phim == 'V') {
1309:  MOVF   34,W
130A:  SUBLW  56
130B:  BTFSS  03.2
130C:  GOTO   436
....................     LCD_Cmd(LCD_CLEAR);
130D:  MOVLW  01
130E:  MOVWF  6A
130F:  BCF    0A.4
1310:  CALL   0FC
1311:  BSF    0A.4
....................     LCD_Goto(1,1);
1312:  MOVLW  01
1313:  MOVWF  67
1314:  MOVWF  68
1315:  BCF    0A.4
1316:  CALL   146
1317:  BSF    0A.4
....................     // D?ng 1: A 
....................     sprintf(buf, "A=%ld", ANS);
1318:  CLRF   33
1319:  MOVLW  46
131A:  MOVWF  32
131B:  MOVLW  41
131C:  MOVWF  6F
131D:  BCF    0A.4
131E:  CALL   22D
131F:  BSF    0A.4
1320:  MOVLW  3D
1321:  MOVWF  6F
1322:  BCF    0A.4
1323:  CALL   22D
1324:  BSF    0A.4
1325:  MOVLW  10
1326:  MOVWF  04
1327:  MOVF   2B,W
1328:  MOVWF  67
1329:  MOVF   2A,W
132A:  MOVWF  66
132B:  BCF    0A.4
132C:  CALL   23A
132D:  BSF    0A.4
....................     for(int i=0; buf[i] && i<7; i++) LCD_Out(buf[i]);
132E:  CLRF   55
132F:  MOVLW  46
1330:  ADDWF  55,W
1331:  MOVWF  04
1332:  BCF    03.7
1333:  MOVF   00,F
1334:  BTFSC  03.2
1335:  GOTO   346
1336:  MOVF   55,W
1337:  SUBLW  06
1338:  BTFSS  03.0
1339:  GOTO   346
133A:  MOVLW  46
133B:  ADDWF  55,W
133C:  MOVWF  04
133D:  BCF    03.7
133E:  MOVF   00,W
133F:  MOVWF  66
1340:  MOVWF  67
1341:  BCF    0A.4
1342:  CALL   16D
1343:  BSF    0A.4
1344:  INCF   55,F
1345:  GOTO   32F
....................     LCD_Out(' ');
1346:  MOVLW  20
1347:  MOVWF  67
1348:  BCF    0A.4
1349:  CALL   16D
134A:  BSF    0A.4
....................     
....................     
....................     // D?ng 2: I và J
....................     LCD_Goto(1,2);
134B:  MOVLW  01
134C:  MOVWF  67
134D:  MOVLW  02
134E:  MOVWF  68
134F:  BCF    0A.4
1350:  CALL   146
1351:  BSF    0A.4
....................     sprintf(buf, "I=%ld ;", luu_gia_tri_I);
1352:  CLRF   33
1353:  MOVLW  46
1354:  MOVWF  32
1355:  MOVLW  49
1356:  MOVWF  6F
1357:  BCF    0A.4
1358:  CALL   22D
1359:  BSF    0A.4
135A:  MOVLW  3D
135B:  MOVWF  6F
135C:  BCF    0A.4
135D:  CALL   22D
135E:  BSF    0A.4
135F:  MOVLW  10
1360:  MOVWF  04
1361:  MOVF   2D,W
1362:  MOVWF  67
1363:  MOVF   2C,W
1364:  MOVWF  66
1365:  BCF    0A.4
1366:  CALL   23A
1367:  BSF    0A.4
1368:  MOVLW  20
1369:  MOVWF  6F
136A:  BCF    0A.4
136B:  CALL   22D
136C:  BSF    0A.4
136D:  MOVLW  3B
136E:  MOVWF  6F
136F:  BCF    0A.4
1370:  CALL   22D
1371:  BSF    0A.4
....................     for(int i=0; buf[i] && i<7; i++) LCD_Out(buf[i]);
1372:  CLRF   56
1373:  MOVLW  46
1374:  ADDWF  56,W
1375:  MOVWF  04
1376:  BCF    03.7
1377:  MOVF   00,F
1378:  BTFSC  03.2
1379:  GOTO   38A
137A:  MOVF   56,W
137B:  SUBLW  06
137C:  BTFSS  03.0
137D:  GOTO   38A
137E:  MOVLW  46
137F:  ADDWF  56,W
1380:  MOVWF  04
1381:  BCF    03.7
1382:  MOVF   00,W
1383:  MOVWF  66
1384:  MOVWF  67
1385:  BCF    0A.4
1386:  CALL   16D
1387:  BSF    0A.4
1388:  INCF   56,F
1389:  GOTO   373
....................     LCD_Out(' ');
138A:  MOVLW  20
138B:  MOVWF  67
138C:  BCF    0A.4
138D:  CALL   16D
138E:  BSF    0A.4
....................     sprintf(buf, "J=%ld", luu_gia_tri_J);
138F:  CLRF   33
1390:  MOVLW  46
1391:  MOVWF  32
1392:  MOVLW  4A
1393:  MOVWF  6F
1394:  BCF    0A.4
1395:  CALL   22D
1396:  BSF    0A.4
1397:  MOVLW  3D
1398:  MOVWF  6F
1399:  BCF    0A.4
139A:  CALL   22D
139B:  BSF    0A.4
139C:  MOVLW  10
139D:  MOVWF  04
139E:  MOVF   2F,W
139F:  MOVWF  67
13A0:  MOVF   2E,W
13A1:  MOVWF  66
13A2:  BCF    0A.4
13A3:  CALL   23A
13A4:  BSF    0A.4
....................     for(int i=0; buf[i]; i++) LCD_Out(buf[i]);
13A5:  CLRF   57
13A6:  MOVLW  46
13A7:  ADDWF  57,W
13A8:  MOVWF  04
13A9:  BCF    03.7
13AA:  MOVF   00,F
13AB:  BTFSC  03.2
13AC:  GOTO   3B9
13AD:  MOVLW  46
13AE:  ADDWF  57,W
13AF:  MOVWF  04
13B0:  BCF    03.7
13B1:  MOVF   00,W
13B2:  MOVWF  66
13B3:  MOVWF  67
13B4:  BCF    0A.4
13B5:  CALL   16D
13B6:  BSF    0A.4
13B7:  INCF   57,F
13B8:  GOTO   3A6
....................     
....................     // Ð?I B?M PHÍM B?T K?
....................     while(doc_phim() == 0);  // Ð?i có phím ðý?c b?m
13B9:  BCF    0A.4
13BA:  CALL   17D
13BB:  BSF    0A.4
13BC:  MOVF   78,F
13BD:  BTFSC  03.2
13BE:  GOTO   3B9
....................     
....................     // Xóa màn h?nh và quay l?i
....................     LCD_Cmd(LCD_CLEAR);
13BF:  MOVLW  01
13C0:  MOVWF  6A
13C1:  BCF    0A.4
13C2:  CALL   0FC
13C3:  BSF    0A.4
....................     
....................     if(da_xong) {
13C4:  BTFSS  45.0
13C5:  GOTO   419
....................         // N?u v?a tính xong, hi?n th? l?i k?t qu?
....................         LCD_Goto(1,1);
13C6:  MOVLW  01
13C7:  MOVWF  67
13C8:  MOVWF  68
13C9:  BCF    0A.4
13CA:  CALL   146
13CB:  BSF    0A.4
....................         LCD_Out('K'); LCD_Out('Q');
13CC:  MOVLW  4B
13CD:  MOVWF  67
13CE:  BCF    0A.4
13CF:  CALL   16D
13D0:  BSF    0A.4
13D1:  MOVLW  51
13D2:  MOVWF  67
13D3:  BCF    0A.4
13D4:  CALL   16D
13D5:  BSF    0A.4
....................         LCD_Goto(1,2);
13D6:  MOVLW  01
13D7:  MOVWF  67
13D8:  MOVLW  02
13D9:  MOVWF  68
13DA:  BCF    0A.4
13DB:  CALL   146
13DC:  BSF    0A.4
....................         LCD_Out('=');
13DD:  MOVLW  3D
13DE:  MOVWF  67
13DF:  BCF    0A.4
13E0:  CALL   16D
13E1:  BSF    0A.4
....................         if(loi == 0) {
13E2:  MOVF   30,F
13E3:  BTFSS  03.2
13E4:  GOTO   409
13E5:  MOVF   31,F
13E6:  BTFSS  03.2
13E7:  GOTO   409
....................             sprintf(buf, "%ld", ANS);
13E8:  CLRF   33
13E9:  MOVLW  46
13EA:  MOVWF  32
13EB:  MOVLW  10
13EC:  MOVWF  04
13ED:  MOVF   2B,W
13EE:  MOVWF  67
13EF:  MOVF   2A,W
13F0:  MOVWF  66
13F1:  BCF    0A.4
13F2:  CALL   23A
13F3:  BSF    0A.4
....................             for(int i=0; buf[i]; i++) LCD_Out(buf[i]);
13F4:  CLRF   58
13F5:  MOVLW  46
13F6:  ADDWF  58,W
13F7:  MOVWF  04
13F8:  BCF    03.7
13F9:  MOVF   00,F
13FA:  BTFSC  03.2
13FB:  GOTO   408
13FC:  MOVLW  46
13FD:  ADDWF  58,W
13FE:  MOVWF  04
13FF:  BCF    03.7
1400:  MOVF   00,W
1401:  MOVWF  66
1402:  MOVWF  67
1403:  BCF    0A.4
1404:  CALL   16D
1405:  BSF    0A.4
1406:  INCF   58,F
1407:  GOTO   3F5
....................         } else {
1408:  GOTO   418
....................             LCD_Out('E'); LCD_Out('R'); LCD_Out('R');
1409:  MOVLW  45
140A:  MOVWF  67
140B:  BCF    0A.4
140C:  CALL   16D
140D:  BSF    0A.4
140E:  MOVLW  52
140F:  MOVWF  67
1410:  BCF    0A.4
1411:  CALL   16D
1412:  BSF    0A.4
1413:  MOVLW  52
1414:  MOVWF  67
1415:  BCF    0A.4
1416:  CALL   16D
1417:  BSF    0A.4
....................         }
....................     } else if(vi_tri > 0) {
1418:  GOTO   435
1419:  MOVF   44,F
141A:  BTFSC  03.2
141B:  GOTO   434
....................         // N?u ðang nh?p, hi?n th? l?i bi?u th?c
....................         LCD_Goto(1,1);
141C:  MOVLW  01
141D:  MOVWF  67
141E:  MOVWF  68
141F:  BCF    0A.4
1420:  CALL   146
1421:  BSF    0A.4
....................         for(int i=0; i<vi_tri; i++) {
1422:  CLRF   59
1423:  MOVF   44,W
1424:  SUBWF  59,W
1425:  BTFSC  03.0
1426:  GOTO   433
....................             LCD_Out(bieu_thuc[i]);
1427:  MOVLW  35
1428:  ADDWF  59,W
1429:  MOVWF  04
142A:  BCF    03.7
142B:  MOVF   00,W
142C:  MOVWF  66
142D:  MOVWF  67
142E:  BCF    0A.4
142F:  CALL   16D
1430:  BSF    0A.4
1431:  INCF   59,F
1432:  GOTO   423
....................         }
....................     } else {
1433:  GOTO   435
....................         // Màn h?nh tr?ng, quay v? màn h?nh ban ð?u
....................         man_hinh_ban_dau = 1;
1434:  BSF    45.1
....................     }
....................     
.................... }
1435:  GOTO   7F8
.................... // ABS (|)
.................... else if(phim == '|') {
1436:  MOVF   34,W
1437:  SUBLW  7C
1438:  BTFSS  03.2
1439:  GOTO   4D0
....................     signed long kq;
....................     
....................     if(da_xong) {
143A:  BTFSS  45.0
143B:  GOTO   441
....................         kq = ANS;
143C:  MOVF   2B,W
143D:  MOVWF  5B
143E:  MOVF   2A,W
143F:  MOVWF  5A
....................     } else if(vi_tri > 0) {
1440:  GOTO   47D
1441:  MOVF   44,F
1442:  BTFSC  03.2
1443:  GOTO   47C
....................         kq = tinh_bieu_thuc(bieu_thuc);
1444:  CLRF   67
1445:  MOVLW  35
1446:  MOVWF  66
1447:  BCF    0A.4
1448:  BSF    0A.3
1449:  CALL   000
144A:  BSF    0A.4
144B:  BCF    0A.3
144C:  MOVF   79,W
144D:  MOVWF  5B
144E:  MOVF   78,W
144F:  MOVWF  5A
....................         if(loi != 0) {
1450:  MOVF   30,F
1451:  BTFSS  03.2
1452:  GOTO   456
1453:  MOVF   31,F
1454:  BTFSC  03.2
1455:  GOTO   47A
....................             LCD_Cmd(LCD_CLEAR);
1456:  MOVLW  01
1457:  MOVWF  6A
1458:  BCF    0A.4
1459:  CALL   0FC
145A:  BSF    0A.4
....................             LCD_Goto(1,1);
145B:  MOVLW  01
145C:  MOVWF  67
145D:  MOVWF  68
145E:  BCF    0A.4
145F:  CALL   146
1460:  BSF    0A.4
....................             LCD_Out('E'); LCD_Out('R'); LCD_Out('R');
1461:  MOVLW  45
1462:  MOVWF  67
1463:  BCF    0A.4
1464:  CALL   16D
1465:  BSF    0A.4
1466:  MOVLW  52
1467:  MOVWF  67
1468:  BCF    0A.4
1469:  CALL   16D
146A:  BSF    0A.4
146B:  MOVLW  52
146C:  MOVWF  67
146D:  BCF    0A.4
146E:  CALL   16D
146F:  BSF    0A.4
....................             delay_ms(1000);
1470:  MOVLW  04
1471:  MOVWF  66
1472:  MOVLW  FA
1473:  MOVWF  67
1474:  BCF    0A.4
1475:  CALL   02C
1476:  BSF    0A.4
1477:  DECFSZ 66,F
1478:  GOTO   472
....................             continue;
1479:  GOTO   097
....................         }
....................         da_xong = 1;
147A:  BSF    45.0
....................     } else {
147B:  GOTO   47D
....................         continue;
147C:  GOTO   097
....................     }
....................     
....................     if(kq < 0) kq = -kq;
147D:  BTFSC  5B.7
147E:  GOTO   480
147F:  GOTO   485
1480:  COMF   5A,F
1481:  COMF   5B,F
1482:  INCF   5A,F
1483:  BTFSC  03.2
1484:  INCF   5B,F
....................     ANS = kq;
1485:  MOVF   5B,W
1486:  MOVWF  2B
1487:  MOVF   5A,W
1488:  MOVWF  2A
....................     
....................     // Hi?n th?
....................     LCD_Cmd(LCD_CLEAR);
1489:  MOVLW  01
148A:  MOVWF  6A
148B:  BCF    0A.4
148C:  CALL   0FC
148D:  BSF    0A.4
....................     LCD_Goto(1,1);
148E:  MOVLW  01
148F:  MOVWF  67
1490:  MOVWF  68
1491:  BCF    0A.4
1492:  CALL   146
1493:  BSF    0A.4
....................     LCD_Out('A'); LCD_Out('B'); LCD_Out('S');
1494:  MOVLW  41
1495:  MOVWF  67
1496:  BCF    0A.4
1497:  CALL   16D
1498:  BSF    0A.4
1499:  MOVLW  42
149A:  MOVWF  67
149B:  BCF    0A.4
149C:  CALL   16D
149D:  BSF    0A.4
149E:  MOVLW  53
149F:  MOVWF  67
14A0:  BCF    0A.4
14A1:  CALL   16D
14A2:  BSF    0A.4
....................     LCD_Goto(1,2);
14A3:  MOVLW  01
14A4:  MOVWF  67
14A5:  MOVLW  02
14A6:  MOVWF  68
14A7:  BCF    0A.4
14A8:  CALL   146
14A9:  BSF    0A.4
....................     LCD_Out('=');
14AA:  MOVLW  3D
14AB:  MOVWF  67
14AC:  BCF    0A.4
14AD:  CALL   16D
14AE:  BSF    0A.4
....................     sprintf(buf, "%ld", ANS);
14AF:  CLRF   33
14B0:  MOVLW  46
14B1:  MOVWF  32
14B2:  MOVLW  10
14B3:  MOVWF  04
14B4:  MOVF   2B,W
14B5:  MOVWF  67
14B6:  MOVF   2A,W
14B7:  MOVWF  66
14B8:  BCF    0A.4
14B9:  CALL   23A
14BA:  BSF    0A.4
....................     for(int i=0; buf[i]; i++) LCD_Out(buf[i]);
14BB:  CLRF   5C
14BC:  MOVLW  46
14BD:  ADDWF  5C,W
14BE:  MOVWF  04
14BF:  BCF    03.7
14C0:  MOVF   00,F
14C1:  BTFSC  03.2
14C2:  GOTO   4CF
14C3:  MOVLW  46
14C4:  ADDWF  5C,W
14C5:  MOVWF  04
14C6:  BCF    03.7
14C7:  MOVF   00,W
14C8:  MOVWF  66
14C9:  MOVWF  67
14CA:  BCF    0A.4
14CB:  CALL   16D
14CC:  BSF    0A.4
14CD:  INCF   5C,F
14CE:  GOTO   4BC
.................... }
14CF:  GOTO   7F8
.................... 
.................... // SQRT (Q)
.................... else if(phim == 'Q') {
14D0:  MOVF   34,W
14D1:  SUBLW  51
14D2:  BTFSS  03.2
14D3:  GOTO   5BA
....................     signed long kq;
....................     
....................     if(da_xong) {
14D4:  BTFSS  45.0
14D5:  GOTO   4DB
....................         kq = ANS;
14D6:  MOVF   2B,W
14D7:  MOVWF  5E
14D8:  MOVF   2A,W
14D9:  MOVWF  5D
....................     } else if(vi_tri > 0) {
14DA:  GOTO   517
14DB:  MOVF   44,F
14DC:  BTFSC  03.2
14DD:  GOTO   516
....................         kq = tinh_bieu_thuc(bieu_thuc);
14DE:  CLRF   67
14DF:  MOVLW  35
14E0:  MOVWF  66
14E1:  BCF    0A.4
14E2:  BSF    0A.3
14E3:  CALL   000
14E4:  BSF    0A.4
14E5:  BCF    0A.3
14E6:  MOVF   79,W
14E7:  MOVWF  5E
14E8:  MOVF   78,W
14E9:  MOVWF  5D
....................         if(loi != 0) {
14EA:  MOVF   30,F
14EB:  BTFSS  03.2
14EC:  GOTO   4F0
14ED:  MOVF   31,F
14EE:  BTFSC  03.2
14EF:  GOTO   514
....................             LCD_Cmd(LCD_CLEAR);
14F0:  MOVLW  01
14F1:  MOVWF  6A
14F2:  BCF    0A.4
14F3:  CALL   0FC
14F4:  BSF    0A.4
....................             LCD_Goto(1,1);
14F5:  MOVLW  01
14F6:  MOVWF  67
14F7:  MOVWF  68
14F8:  BCF    0A.4
14F9:  CALL   146
14FA:  BSF    0A.4
....................             LCD_Out('E'); LCD_Out('R'); LCD_Out('R');
14FB:  MOVLW  45
14FC:  MOVWF  67
14FD:  BCF    0A.4
14FE:  CALL   16D
14FF:  BSF    0A.4
1500:  MOVLW  52
1501:  MOVWF  67
1502:  BCF    0A.4
1503:  CALL   16D
1504:  BSF    0A.4
1505:  MOVLW  52
1506:  MOVWF  67
1507:  BCF    0A.4
1508:  CALL   16D
1509:  BSF    0A.4
....................             delay_ms(1000);
150A:  MOVLW  04
150B:  MOVWF  66
150C:  MOVLW  FA
150D:  MOVWF  67
150E:  BCF    0A.4
150F:  CALL   02C
1510:  BSF    0A.4
1511:  DECFSZ 66,F
1512:  GOTO   50C
....................             continue;
1513:  GOTO   097
....................         }
....................         da_xong = 1;
1514:  BSF    45.0
....................     } else {
1515:  GOTO   517
....................         continue;
1516:  GOTO   097
....................     }
....................     
....................     if(kq < 0) {
1517:  BTFSC  5E.7
1518:  GOTO   51A
1519:  GOTO   563
....................         LCD_Cmd(LCD_CLEAR);
151A:  MOVLW  01
151B:  MOVWF  6A
151C:  BCF    0A.4
151D:  CALL   0FC
151E:  BSF    0A.4
....................         LCD_Goto(1,1);
151F:  MOVLW  01
1520:  MOVWF  67
1521:  MOVWF  68
1522:  BCF    0A.4
1523:  CALL   146
1524:  BSF    0A.4
....................         LCD_Out('E'); LCD_Out('R'); LCD_Out('R');
1525:  MOVLW  45
1526:  MOVWF  67
1527:  BCF    0A.4
1528:  CALL   16D
1529:  BSF    0A.4
152A:  MOVLW  52
152B:  MOVWF  67
152C:  BCF    0A.4
152D:  CALL   16D
152E:  BSF    0A.4
152F:  MOVLW  52
1530:  MOVWF  67
1531:  BCF    0A.4
1532:  CALL   16D
1533:  BSF    0A.4
....................         LCD_Goto(1,2);
1534:  MOVLW  01
1535:  MOVWF  67
1536:  MOVLW  02
1537:  MOVWF  68
1538:  BCF    0A.4
1539:  CALL   146
153A:  BSF    0A.4
....................         LCD_Out('S'); LCD_Out('Q'); LCD_Out('R'); LCD_Out('T');
153B:  MOVLW  53
153C:  MOVWF  67
153D:  BCF    0A.4
153E:  CALL   16D
153F:  BSF    0A.4
1540:  MOVLW  51
1541:  MOVWF  67
1542:  BCF    0A.4
1543:  CALL   16D
1544:  BSF    0A.4
1545:  MOVLW  52
1546:  MOVWF  67
1547:  BCF    0A.4
1548:  CALL   16D
1549:  BSF    0A.4
154A:  MOVLW  54
154B:  MOVWF  67
154C:  BCF    0A.4
154D:  CALL   16D
154E:  BSF    0A.4
....................         LCD_Out('<'); LCD_Out('0');
154F:  MOVLW  3C
1550:  MOVWF  67
1551:  BCF    0A.4
1552:  CALL   16D
1553:  BSF    0A.4
1554:  MOVLW  30
1555:  MOVWF  67
1556:  BCF    0A.4
1557:  CALL   16D
1558:  BSF    0A.4
....................         delay_ms(1500);
1559:  MOVLW  06
155A:  MOVWF  66
155B:  MOVLW  FA
155C:  MOVWF  67
155D:  BCF    0A.4
155E:  CALL   02C
155F:  BSF    0A.4
1560:  DECFSZ 66,F
1561:  GOTO   55B
....................         continue;
1562:  GOTO   097
....................     }
....................     
....................     ANS = tinh_sqrt(kq);
1563:  MOVF   5E,W
1564:  MOVWF  67
1565:  MOVF   5D,W
1566:  MOVWF  66
1567:  BCF    0A.4
1568:  GOTO   556
1569:  BSF    0A.4
156A:  MOVF   79,W
156B:  MOVWF  2B
156C:  MOVF   78,W
156D:  MOVWF  2A
....................     
....................     // Hi?n th?
....................     LCD_Cmd(LCD_CLEAR);
156E:  MOVLW  01
156F:  MOVWF  6A
1570:  BCF    0A.4
1571:  CALL   0FC
1572:  BSF    0A.4
....................     LCD_Goto(1,1);
1573:  MOVLW  01
1574:  MOVWF  67
1575:  MOVWF  68
1576:  BCF    0A.4
1577:  CALL   146
1578:  BSF    0A.4
....................     LCD_Out('S'); LCD_Out('Q'); LCD_Out('R'); LCD_Out('T');
1579:  MOVLW  53
157A:  MOVWF  67
157B:  BCF    0A.4
157C:  CALL   16D
157D:  BSF    0A.4
157E:  MOVLW  51
157F:  MOVWF  67
1580:  BCF    0A.4
1581:  CALL   16D
1582:  BSF    0A.4
1583:  MOVLW  52
1584:  MOVWF  67
1585:  BCF    0A.4
1586:  CALL   16D
1587:  BSF    0A.4
1588:  MOVLW  54
1589:  MOVWF  67
158A:  BCF    0A.4
158B:  CALL   16D
158C:  BSF    0A.4
....................     LCD_Goto(1,2);
158D:  MOVLW  01
158E:  MOVWF  67
158F:  MOVLW  02
1590:  MOVWF  68
1591:  BCF    0A.4
1592:  CALL   146
1593:  BSF    0A.4
....................     LCD_Out('=');
1594:  MOVLW  3D
1595:  MOVWF  67
1596:  BCF    0A.4
1597:  CALL   16D
1598:  BSF    0A.4
....................     sprintf(buf, "%ld", ANS);
1599:  CLRF   33
159A:  MOVLW  46
159B:  MOVWF  32
159C:  MOVLW  10
159D:  MOVWF  04
159E:  MOVF   2B,W
159F:  MOVWF  67
15A0:  MOVF   2A,W
15A1:  MOVWF  66
15A2:  BCF    0A.4
15A3:  CALL   23A
15A4:  BSF    0A.4
....................     for(int i=0; buf[i]; i++) LCD_Out(buf[i]);
15A5:  CLRF   5F
15A6:  MOVLW  46
15A7:  ADDWF  5F,W
15A8:  MOVWF  04
15A9:  BCF    03.7
15AA:  MOVF   00,F
15AB:  BTFSC  03.2
15AC:  GOTO   5B9
15AD:  MOVLW  46
15AE:  ADDWF  5F,W
15AF:  MOVWF  04
15B0:  BCF    03.7
15B1:  MOVF   00,W
15B2:  MOVWF  66
15B3:  MOVWF  67
15B4:  BCF    0A.4
15B5:  CALL   16D
15B6:  BSF    0A.4
15B7:  INCF   5F,F
15B8:  GOTO   5A6
.................... }
15B9:  GOTO   7F8
....................             // ANS
....................            // ANS (hi?n th? ch? A thay v? s?)
.................... // ANS (hi?n th? ch? A thay v? s?)
.................... else if(phim == 'A') {
15BA:  MOVF   34,W
15BB:  SUBLW  41
15BC:  BTFSS  03.2
15BD:  GOTO   5E5
....................     // N?u v?a tính xong, clear màn h?nh
....................     if(da_xong) {
15BE:  BTFSS  45.0
15BF:  GOTO   5C8
....................         LCD_Cmd(LCD_CLEAR);
15C0:  MOVLW  01
15C1:  MOVWF  6A
15C2:  BCF    0A.4
15C3:  CALL   0FC
15C4:  BSF    0A.4
....................         vi_tri = 0;
15C5:  CLRF   44
....................         bieu_thuc[0] = '\0';
15C6:  CLRF   35
....................         da_xong = 0;
15C7:  BCF    45.0
....................     }
....................     
....................     // Thêm k? t? 'A' vào bi?u th?c
....................     if(vi_tri < 14) {
15C8:  MOVF   44,W
15C9:  SUBLW  0D
15CA:  BTFSS  03.0
15CB:  GOTO   5E4
....................         bieu_thuc[vi_tri++] = 'A';
15CC:  MOVF   44,W
15CD:  INCF   44,F
15CE:  ADDLW  35
15CF:  MOVWF  04
15D0:  BCF    03.7
15D1:  MOVLW  41
15D2:  MOVWF  00
....................         bieu_thuc[vi_tri] = '\0';
15D3:  MOVLW  35
15D4:  ADDWF  44,W
15D5:  MOVWF  04
15D6:  BCF    03.7
15D7:  CLRF   00
....................         LCD_Goto(vi_tri,1);
15D8:  MOVF   44,W
15D9:  MOVWF  67
15DA:  MOVLW  01
15DB:  MOVWF  68
15DC:  BCF    0A.4
15DD:  CALL   146
15DE:  BSF    0A.4
....................         LCD_Out('A');
15DF:  MOVLW  41
15E0:  MOVWF  67
15E1:  BCF    0A.4
15E2:  CALL   16D
15E3:  BSF    0A.4
....................     }
.................... }
15E4:  GOTO   7F8
.................... 
.................... else if(phim == 'X') {
15E5:  MOVF   34,W
15E6:  SUBLW  58
15E7:  BTFSS  03.2
15E8:  GOTO   65E
....................     ANS = 0;
15E9:  CLRF   2B
15EA:  CLRF   2A
....................     luu_gia_tri_I = 0;
15EB:  CLRF   2D
15EC:  CLRF   2C
....................     luu_gia_tri_J = 0;
15ED:  CLRF   2F
15EE:  CLRF   2E
....................     
....................     LCD_Cmd(LCD_CLEAR);
15EF:  MOVLW  01
15F0:  MOVWF  6A
15F1:  BCF    0A.4
15F2:  CALL   0FC
15F3:  BSF    0A.4
....................     LCD_Goto(1,1);
15F4:  MOVLW  01
15F5:  MOVWF  67
15F6:  MOVWF  68
15F7:  BCF    0A.4
15F8:  CALL   146
15F9:  BSF    0A.4
....................     LCD_Out('C'); LCD_Out('L'); LCD_Out('R'); LCD_Out(' ');
15FA:  MOVLW  43
15FB:  MOVWF  67
15FC:  BCF    0A.4
15FD:  CALL   16D
15FE:  BSF    0A.4
15FF:  MOVLW  4C
1600:  MOVWF  67
1601:  BCF    0A.4
1602:  CALL   16D
1603:  BSF    0A.4
1604:  MOVLW  52
1605:  MOVWF  67
1606:  BCF    0A.4
1607:  CALL   16D
1608:  BSF    0A.4
1609:  MOVLW  20
160A:  MOVWF  67
160B:  BCF    0A.4
160C:  CALL   16D
160D:  BSF    0A.4
....................     LCD_Out('M'); LCD_Out('E'); LCD_Out('M');
160E:  MOVLW  4D
160F:  MOVWF  67
1610:  BCF    0A.4
1611:  CALL   16D
1612:  BSF    0A.4
1613:  MOVLW  45
1614:  MOVWF  67
1615:  BCF    0A.4
1616:  CALL   16D
1617:  BSF    0A.4
1618:  MOVLW  4D
1619:  MOVWF  67
161A:  BCF    0A.4
161B:  CALL   16D
161C:  BSF    0A.4
....................     delay_ms(1000);
161D:  MOVLW  04
161E:  MOVWF  66
161F:  MOVLW  FA
1620:  MOVWF  67
1621:  BCF    0A.4
1622:  CALL   02C
1623:  BSF    0A.4
1624:  DECFSZ 66,F
1625:  GOTO   61F
....................     
....................     LCD_Cmd(LCD_CLEAR);
1626:  MOVLW  01
1627:  MOVWF  6A
1628:  BCF    0A.4
1629:  CALL   0FC
162A:  BSF    0A.4
....................     LCD_Goto(1,1);
162B:  MOVLW  01
162C:  MOVWF  67
162D:  MOVWF  68
162E:  BCF    0A.4
162F:  CALL   146
1630:  BSF    0A.4
....................     LCD_Out('X'); LCD_Out('I'); LCD_Out('N'); LCD_Out(' ');
1631:  MOVLW  58
1632:  MOVWF  67
1633:  BCF    0A.4
1634:  CALL   16D
1635:  BSF    0A.4
1636:  MOVLW  49
1637:  MOVWF  67
1638:  BCF    0A.4
1639:  CALL   16D
163A:  BSF    0A.4
163B:  MOVLW  4E
163C:  MOVWF  67
163D:  BCF    0A.4
163E:  CALL   16D
163F:  BSF    0A.4
1640:  MOVLW  20
1641:  MOVWF  67
1642:  BCF    0A.4
1643:  CALL   16D
1644:  BSF    0A.4
....................     LCD_Out('C'); LCD_Out('H'); LCD_Out('A'); LCD_Out('O');
1645:  MOVLW  43
1646:  MOVWF  67
1647:  BCF    0A.4
1648:  CALL   16D
1649:  BSF    0A.4
164A:  MOVLW  48
164B:  MOVWF  67
164C:  BCF    0A.4
164D:  CALL   16D
164E:  BSF    0A.4
164F:  MOVLW  41
1650:  MOVWF  67
1651:  BCF    0A.4
1652:  CALL   16D
1653:  BSF    0A.4
1654:  MOVLW  4F
1655:  MOVWF  67
1656:  BCF    0A.4
1657:  CALL   16D
1658:  BSF    0A.4
....................     
....................     vi_tri = 0;
1659:  CLRF   44
....................     bieu_thuc[0] = '\0';
165A:  CLRF   35
....................     da_xong = 0;
165B:  BCF    45.0
....................     man_hinh_ban_dau = 1;
165C:  BSF    45.1
.................... }
165D:  GOTO   7F8
.................... 
.................... 
.................... 
.................... // ! (GIAI TH?A SAU KHI =)
.................... else if(phim == '!' && da_xong) {
165E:  MOVF   34,W
165F:  SUBLW  21
1660:  BTFSS  03.2
1661:  GOTO   6CC
1662:  BTFSS  45.0
1663:  GOTO   6CC
.................... 
....................     // clear màn h?nh k?t qu?
....................     LCD_Cmd(LCD_CLEAR);
1664:  MOVLW  01
1665:  MOVWF  6A
1666:  BCF    0A.4
1667:  CALL   0FC
1668:  BSF    0A.4
.................... 
....................     // ðýa ANS vào l?i bi?u th?c
....................     sprintf(buf, "%ld", ANS);
1669:  CLRF   33
166A:  MOVLW  46
166B:  MOVWF  32
166C:  MOVLW  10
166D:  MOVWF  04
166E:  MOVF   2B,W
166F:  MOVWF  67
1670:  MOVF   2A,W
1671:  MOVWF  66
1672:  BCF    0A.4
1673:  CALL   23A
1674:  BSF    0A.4
....................     vi_tri = 0;
1675:  CLRF   44
....................     for(int i = 0; buf[i] && vi_tri < 14; i++) {
1676:  CLRF   60
1677:  MOVLW  46
1678:  ADDWF  60,W
1679:  MOVWF  04
167A:  BCF    03.7
167B:  MOVF   00,F
167C:  BTFSC  03.2
167D:  GOTO   6AE
167E:  MOVF   44,W
167F:  SUBLW  0D
1680:  BTFSS  03.0
1681:  GOTO   6AE
....................         bieu_thuc[vi_tri++] = buf[i];
1682:  MOVF   44,W
1683:  INCF   44,F
1684:  ADDLW  35
1685:  MOVWF  66
1686:  CLRF   67
1687:  BTFSC  03.0
1688:  INCF   67,F
1689:  MOVLW  46
168A:  ADDWF  60,W
168B:  MOVWF  04
168C:  BCF    03.7
168D:  MOVF   00,W
168E:  MOVWF  68
168F:  MOVF   66,W
1690:  MOVWF  04
1691:  BCF    03.7
1692:  BTFSC  67.0
1693:  BSF    03.7
1694:  MOVF   68,W
1695:  MOVWF  00
....................         bieu_thuc[vi_tri] = '\0';
1696:  MOVLW  35
1697:  ADDWF  44,W
1698:  MOVWF  04
1699:  BCF    03.7
169A:  CLRF   00
....................         LCD_Goto(vi_tri, 1);
169B:  MOVF   44,W
169C:  MOVWF  67
169D:  MOVLW  01
169E:  MOVWF  68
169F:  BCF    0A.4
16A0:  CALL   146
16A1:  BSF    0A.4
....................         LCD_Out(buf[i]);
16A2:  MOVLW  46
16A3:  ADDWF  60,W
16A4:  MOVWF  04
16A5:  BCF    03.7
16A6:  MOVF   00,W
16A7:  MOVWF  66
16A8:  MOVWF  67
16A9:  BCF    0A.4
16AA:  CALL   16D
16AB:  BSF    0A.4
16AC:  INCF   60,F
16AD:  GOTO   677
....................     }
.................... 
....................     // thêm d?u !
....................     if(vi_tri < 14) {
16AE:  MOVF   44,W
16AF:  SUBLW  0D
16B0:  BTFSS  03.0
16B1:  GOTO   6CA
....................         bieu_thuc[vi_tri++] = '!';
16B2:  MOVF   44,W
16B3:  INCF   44,F
16B4:  ADDLW  35
16B5:  MOVWF  04
16B6:  BCF    03.7
16B7:  MOVLW  21
16B8:  MOVWF  00
....................         bieu_thuc[vi_tri] = '\0';
16B9:  MOVLW  35
16BA:  ADDWF  44,W
16BB:  MOVWF  04
16BC:  BCF    03.7
16BD:  CLRF   00
....................         LCD_Goto(vi_tri, 1);
16BE:  MOVF   44,W
16BF:  MOVWF  67
16C0:  MOVLW  01
16C1:  MOVWF  68
16C2:  BCF    0A.4
16C3:  CALL   146
16C4:  BSF    0A.4
....................         LCD_Out('!');
16C5:  MOVLW  21
16C6:  MOVWF  67
16C7:  BCF    0A.4
16C8:  CALL   16D
16C9:  BSF    0A.4
....................     }
.................... 
....................     da_xong = 0;   // quay v? tr?ng thái nh?p
16CA:  BCF    45.0
.................... }
16CB:  GOTO   7F8
.................... 
.................... 
....................             // =
....................            else if(phim == '=') {
16CC:  MOVF   34,W
16CD:  SUBLW  3D
16CE:  BTFSS  03.2
16CF:  GOTO   758
....................     if(vi_tri > 0) {
16D0:  MOVF   44,F
16D1:  BTFSC  03.2
16D2:  GOTO   757
....................         int am_trong_ngoac = 0;
16D3:  CLRF   61
....................         if(bieu_thuc[0] == '(' && bieu_thuc[1] == '-') {
16D4:  MOVF   35,W
16D5:  SUBLW  28
16D6:  BTFSS  03.2
16D7:  GOTO   6DE
16D8:  MOVF   36,W
16D9:  SUBLW  2D
16DA:  BTFSS  03.2
16DB:  GOTO   6DE
....................             am_trong_ngoac = 1;
16DC:  MOVLW  01
16DD:  MOVWF  61
....................         }
.................... 
....................         long int kq = tinh_bieu_thuc(bieu_thuc);
16DE:  CLRF   67
16DF:  MOVLW  35
16E0:  MOVWF  66
16E1:  BCF    0A.4
16E2:  BSF    0A.3
16E3:  CALL   000
16E4:  BSF    0A.4
16E5:  BCF    0A.3
16E6:  MOVF   79,W
16E7:  MOVWF  63
16E8:  MOVF   78,W
16E9:  MOVWF  62
.................... 
....................         LCD_Cmd(LCD_CLEAR);
16EA:  MOVLW  01
16EB:  MOVWF  6A
16EC:  BCF    0A.4
16ED:  CALL   0FC
16EE:  BSF    0A.4
....................         LCD_Goto(1,1);
16EF:  MOVLW  01
16F0:  MOVWF  67
16F1:  MOVWF  68
16F2:  BCF    0A.4
16F3:  CALL   146
16F4:  BSF    0A.4
....................         LCD_Out('K'); LCD_Out('Q');  // Ð?i t? KET QUA ? KQ
16F5:  MOVLW  4B
16F6:  MOVWF  67
16F7:  BCF    0A.4
16F8:  CALL   16D
16F9:  BSF    0A.4
16FA:  MOVLW  51
16FB:  MOVWF  67
16FC:  BCF    0A.4
16FD:  CALL   16D
16FE:  BSF    0A.4
....................         LCD_Goto(1,2);
16FF:  MOVLW  01
1700:  MOVWF  67
1701:  MOVLW  02
1702:  MOVWF  68
1703:  BCF    0A.4
1704:  CALL   146
1705:  BSF    0A.4
....................         LCD_Out('=');
1706:  MOVLW  3D
1707:  MOVWF  67
1708:  BCF    0A.4
1709:  CALL   16D
170A:  BSF    0A.4
.................... 
....................         if(loi == 0) {
170B:  MOVF   30,F
170C:  BTFSS  03.2
170D:  GOTO   747
170E:  MOVF   31,F
170F:  BTFSS  03.2
1710:  GOTO   747
....................             if(am_trong_ngoac && !la_mu_chan(bieu_thuc)) {
1711:  MOVF   61,F
1712:  BTFSC  03.2
1713:  GOTO   722
1714:  CLRF   67
1715:  MOVLW  35
1716:  MOVWF  66
1717:  BCF    0A.4
1718:  GOTO   5B5
1719:  BSF    0A.4
171A:  MOVF   78,F
171B:  BTFSS  03.2
171C:  GOTO   722
....................                 kq = 0 - kq;
171D:  COMF   62,F
171E:  COMF   63,F
171F:  INCF   62,F
1720:  BTFSC  03.2
1721:  INCF   63,F
....................             }
....................             sprintf(buf, "%ld", kq);
1722:  CLRF   33
1723:  MOVLW  46
1724:  MOVWF  32
1725:  MOVLW  10
1726:  MOVWF  04
1727:  MOVF   63,W
1728:  MOVWF  67
1729:  MOVF   62,W
172A:  MOVWF  66
172B:  BCF    0A.4
172C:  CALL   23A
172D:  BSF    0A.4
....................             for(int i=0; buf[i]; i++) LCD_Out(buf[i]);
172E:  CLRF   64
172F:  MOVLW  46
1730:  ADDWF  64,W
1731:  MOVWF  04
1732:  BCF    03.7
1733:  MOVF   00,F
1734:  BTFSC  03.2
1735:  GOTO   742
1736:  MOVLW  46
1737:  ADDWF  64,W
1738:  MOVWF  04
1739:  BCF    03.7
173A:  MOVF   00,W
173B:  MOVWF  66
173C:  MOVWF  67
173D:  BCF    0A.4
173E:  CALL   16D
173F:  BSF    0A.4
1740:  INCF   64,F
1741:  GOTO   72F
....................             ANS = kq;
1742:  MOVF   63,W
1743:  MOVWF  2B
1744:  MOVF   62,W
1745:  MOVWF  2A
....................         } else {
1746:  GOTO   756
....................             LCD_Out('E'); LCD_Out('R'); LCD_Out('R');
1747:  MOVLW  45
1748:  MOVWF  67
1749:  BCF    0A.4
174A:  CALL   16D
174B:  BSF    0A.4
174C:  MOVLW  52
174D:  MOVWF  67
174E:  BCF    0A.4
174F:  CALL   16D
1750:  BSF    0A.4
1751:  MOVLW  52
1752:  MOVWF  67
1753:  BCF    0A.4
1754:  CALL   16D
1755:  BSF    0A.4
....................         }
....................         da_xong = 1;
1756:  BSF    45.0
....................     }
.................... }
1757:  GOTO   7F8
.................... 
.................... 
....................             // TOÁN T? SAU KHI =
....................             else if(da_xong && (phim=='+' || phim=='-' || phim=='*' || phim=='/')) {
1758:  BTFSS  45.0
1759:  GOTO   7D2
175A:  MOVF   34,W
175B:  SUBLW  2B
175C:  BTFSC  03.2
175D:  GOTO   76A
175E:  MOVF   34,W
175F:  SUBLW  2D
1760:  BTFSC  03.2
1761:  GOTO   76A
1762:  MOVF   34,W
1763:  SUBLW  2A
1764:  BTFSC  03.2
1765:  GOTO   76A
1766:  MOVF   34,W
1767:  SUBLW  2F
1768:  BTFSS  03.2
1769:  GOTO   7D2
....................                 LCD_Cmd(LCD_CLEAR);
176A:  MOVLW  01
176B:  MOVWF  6A
176C:  BCF    0A.4
176D:  CALL   0FC
176E:  BSF    0A.4
....................                 sprintf(buf, "%ld", ANS);
176F:  CLRF   33
1770:  MOVLW  46
1771:  MOVWF  32
1772:  MOVLW  10
1773:  MOVWF  04
1774:  MOVF   2B,W
1775:  MOVWF  67
1776:  MOVF   2A,W
1777:  MOVWF  66
1778:  BCF    0A.4
1779:  CALL   23A
177A:  BSF    0A.4
....................                 vi_tri = 0;
177B:  CLRF   44
....................                 for(int i=0; buf[i] && vi_tri < 14; i++) {
177C:  CLRF   65
177D:  MOVLW  46
177E:  ADDWF  65,W
177F:  MOVWF  04
1780:  BCF    03.7
1781:  MOVF   00,F
1782:  BTFSC  03.2
1783:  GOTO   7B4
1784:  MOVF   44,W
1785:  SUBLW  0D
1786:  BTFSS  03.0
1787:  GOTO   7B4
....................                     bieu_thuc[vi_tri++] = buf[i];
1788:  MOVF   44,W
1789:  INCF   44,F
178A:  ADDLW  35
178B:  MOVWF  66
178C:  CLRF   67
178D:  BTFSC  03.0
178E:  INCF   67,F
178F:  MOVLW  46
1790:  ADDWF  65,W
1791:  MOVWF  04
1792:  BCF    03.7
1793:  MOVF   00,W
1794:  MOVWF  68
1795:  MOVF   66,W
1796:  MOVWF  04
1797:  BCF    03.7
1798:  BTFSC  67.0
1799:  BSF    03.7
179A:  MOVF   68,W
179B:  MOVWF  00
....................                     bieu_thuc[vi_tri] = '\0';
179C:  MOVLW  35
179D:  ADDWF  44,W
179E:  MOVWF  04
179F:  BCF    03.7
17A0:  CLRF   00
....................                     LCD_Goto(vi_tri,1);
17A1:  MOVF   44,W
17A2:  MOVWF  67
17A3:  MOVLW  01
17A4:  MOVWF  68
17A5:  BCF    0A.4
17A6:  CALL   146
17A7:  BSF    0A.4
....................                     LCD_Out(buf[i]);
17A8:  MOVLW  46
17A9:  ADDWF  65,W
17AA:  MOVWF  04
17AB:  BCF    03.7
17AC:  MOVF   00,W
17AD:  MOVWF  66
17AE:  MOVWF  67
17AF:  BCF    0A.4
17B0:  CALL   16D
17B1:  BSF    0A.4
17B2:  INCF   65,F
17B3:  GOTO   77D
....................                 }
....................                 if(vi_tri < 14) {
17B4:  MOVF   44,W
17B5:  SUBLW  0D
17B6:  BTFSS  03.0
17B7:  GOTO   7D0
....................                     bieu_thuc[vi_tri++] = phim;
17B8:  MOVF   44,W
17B9:  INCF   44,F
17BA:  ADDLW  35
17BB:  MOVWF  04
17BC:  BCF    03.7
17BD:  MOVF   34,W
17BE:  MOVWF  00
....................                     bieu_thuc[vi_tri] = '\0';
17BF:  MOVLW  35
17C0:  ADDWF  44,W
17C1:  MOVWF  04
17C2:  BCF    03.7
17C3:  CLRF   00
....................                     LCD_Goto(vi_tri,1);
17C4:  MOVF   44,W
17C5:  MOVWF  67
17C6:  MOVLW  01
17C7:  MOVWF  68
17C8:  BCF    0A.4
17C9:  CALL   146
17CA:  BSF    0A.4
....................                     LCD_Out(phim);
17CB:  MOVF   34,W
17CC:  MOVWF  67
17CD:  BCF    0A.4
17CE:  CALL   16D
17CF:  BSF    0A.4
....................                 }
....................                 da_xong = 0;
17D0:  BCF    45.0
....................             }
17D1:  GOTO   7F8
.................... 
....................             // NH?P B?NH THÝ?NG
....................             else {
....................                 if(da_xong) {
17D2:  BTFSS  45.0
17D3:  GOTO   7DC
....................                     LCD_Cmd(LCD_CLEAR);
17D4:  MOVLW  01
17D5:  MOVWF  6A
17D6:  BCF    0A.4
17D7:  CALL   0FC
17D8:  BSF    0A.4
....................                     vi_tri = 0;
17D9:  CLRF   44
....................                     bieu_thuc[0] = '\0';
17DA:  CLRF   35
....................                     da_xong = 0;
17DB:  BCF    45.0
....................                 }
....................                 if(vi_tri < 14) {
17DC:  MOVF   44,W
17DD:  SUBLW  0D
17DE:  BTFSS  03.0
17DF:  GOTO   7F8
....................                     bieu_thuc[vi_tri++] = phim;
17E0:  MOVF   44,W
17E1:  INCF   44,F
17E2:  ADDLW  35
17E3:  MOVWF  04
17E4:  BCF    03.7
17E5:  MOVF   34,W
17E6:  MOVWF  00
....................                     bieu_thuc[vi_tri] = '\0';
17E7:  MOVLW  35
17E8:  ADDWF  44,W
17E9:  MOVWF  04
17EA:  BCF    03.7
17EB:  CLRF   00
....................                     LCD_Goto(vi_tri,1);
17EC:  MOVF   44,W
17ED:  MOVWF  67
17EE:  MOVLW  01
17EF:  MOVWF  68
17F0:  BCF    0A.4
17F1:  CALL   146
17F2:  BSF    0A.4
....................                     LCD_Out(phim);
17F3:  MOVF   34,W
17F4:  MOVWF  67
17F5:  BCF    0A.4
17F6:  CALL   16D
17F7:  BSF    0A.4
....................                 }
....................             }
....................         }
17F8:  GOTO   097
....................     }
.................... }
.................... 
17F9:  SLEEP

Configuration Fuses:
   Word  1: 2CF2   HS NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
